{"componentChunkName":"component---node-modules-gatsby-theme-ocular-src-react-templates-search-jsx","path":"/search","result":{"pageContext":{"data":[{"excerpt":"Introduction Welcome to math.gl! math.gl is JavaScript math library focused on  geospatial  and  3D  use cases, designed as a composable,  modular toolbox . math.gl provides a core module with classic vector and matrix classes, and a suite of optional modules implementing various aspects of geospatial and 3D math. While the math.gl is highly  optimized for use with the WebGL and WebGPU APIs , math.gl itself has no WebGL dependencies. Modules math.gl is a toolbox that offers a suite of composable modules. Image Module Description @math.gl/core Basic 3D math classes (vectors, matrices, etc) @math.gl/culling Bounding volumes and intersection testing. @math.gl/geospatial Ellipsoidal math for WGS84 coordinates. @math.gl/geoid Earth Gravity Model support . @math.gl/polygon Polygon math, including geospatial cutting etc. @math.gl/proj4 Conversion between coordinate reference systems. @math.gl/sun Solar position / direction from position and time. @math.gl/web-mercator Supports 3D Web Mercator (spherical) projections. Legacy Module Description math.gl Re-exports the API from  @math.gl/core . An \"alias\" for  @math.gl/core  to avoid breaking old applications. viewport-mercator-project Re-exports the Web Mercator projection utilities in  @math.gl/web-mercator . The  viewport-mercator-project  repository was moved to math.gl in Oct 2019. Supported Browsers and Node Versions math.gl is fully supported on: Evergreen browsers: Recent versions of Chrome, Safari, Firefox, Edge etc. Node.js: Active and Maintenance  LTS releases IE11: Supported (with certain performance caveats) using math.gl's fully transpiled  es5  distribution and  @babel/polyfills . Note that Internet Explorer < 10 will not work. If your application needs to support older browsers, an option could be to use  gl-matrix  directly. History The core classes were originally developed as part of luma.gl v4 to provide a basic 3D math library for the luma.gl and deck.gl frameworks. math.gl was then broken out into its own module to allow it to mature in terms of functionality and stability and make it a proper home for additional 3D and Geospatial modules. parts of the Cesium math library were ported and published as independently usable math.gl modules (the geospatial and culling modules). This was a collaboration with the Cesium team around 3D Tiles support in loaders.gl, Additional geospatial modules have gradually been added to support more advanced use cases for deck.gl. Attributions math.gl was inspired by and built upon some of the most proven open source JavaScript math libraries: gl-matrix  - math.gl classes use gl-matrix under the hood THREE.js math library - math.gl classes are API-compatible with a subset of the THREE.js classes and pass THREE.js test suites. The CesiumJS math library (Apache2) - The geospatial and culling modules were ported from Cesium code base. License MIT license. The libraries that the core  math.gl  module are built on (e.g. gl-matrix) are also all open source and MIT licensed. The  @math.gl/geospatial  and  @math.gl/culling  modules include Cesium-derived code which is Apache2 licensed. math.gl will never include any code that is not under permissive license.","headings":[{"value":"Introduction","depth":1},{"value":"Modules","depth":2},{"value":"Supported Browsers and Node Versions","depth":2},{"value":"History","depth":2},{"value":"Attributions","depth":2},{"value":"License","depth":2}],"slug":"docs","title":"Introduction"},{"excerpt":"Roadmap 3D Primitives Add a submodule with the geometry primitives from luma.gl. Geometry Processing Provide a library for CPU side geometry processing, for calculating normals, ray casting etc. There is initial code in  @loaders.gl/math  that should be cleaned up and moved to math.gl. Improved Columnar Table Support Geometries are essentially columnar tables, emphasize this further to simplify integration with columnar table systems, primarily ArrowJS. GPU Powered Math? TBA Interoperability and Framework Independence An ambition is that math.gl should be able to serve a general purpose 3D math library, enabling the creation of framework-independent 3D and Geospatial code that interoperates with a variety of frameworks. math.gl modules (such as geospatial math) should be usable by applications using other frameworks, without having to use the core math.gl classes.","headings":[{"value":"Roadmap","depth":1},{"value":"3D Primitives","depth":2},{"value":"Geometry Processing","depth":3},{"value":"Improved Columnar Table Support","depth":3},{"value":"GPU Powered Math?","depth":3},{"value":"Interoperability and Framework Independence","depth":2}],"slug":"docs/roadmap","title":"Roadmap"},{"excerpt":"Upgrade Guide Upgrading to v3.0 Matrix API changes Matrix setter functions no longer support ommitted parameters. (Motivation: Increased API rigor, improved debugging and library compactness). Matrix transforms now return Arrays by default The  Matrix4  and  Matrix3  classes no longer by default create new  Vector2 ,  Vector3  and  Vector4  instances. Instead they create standard JavaScript arrays. Previously a new  Vector4  would be allocated if no  result  parameter was provided. Now a plain JavaScript  Array  is allocated The old behavior can be restored by providing the result parameter Motivation: This change reduces dependencies between math.gl core classes which improves tree-shaking and bundle sizes. Matrix setter functions no longer support ommitted parameters Motivation: This change increases rigor, facilitates debugging, and improves library compactness, and the use case for default parameters was questionable. The following functions have been deprecated: Method Replacement Reason Matrix*.setColumnMajor Matrix*.set API simplification Matrix4.transformPoint Matrix4.transform Name alignment Matrix4.transformVector Matrix4.transform Name alignment Matrix4.transformDirection Matrix4.transformAsVector Name alignment Matrix3.transformVector Matrix3.transform Name alignment Matrix3.transformVector2 Matrix3.transform Generalize Matrix3.transformVector3 Matrix3.transform Generalize The following functions have been removed: Method Replacement Reason Vector2.cross Vector3.cross Cross products by definition work on 3 dimensional vectors. Upgrading to v2.0 Experimental exports are now exported with a leading underscore ( _ ), instead of as members of the  experimental  namespace: NOW: math.gl v2 BEFORE: math.gl v1.x The  experimental  name space export has been removed. Upgrading to v1.1 Removed Functionality The  Euler  class is no longer included as an experimental export. It would need to be imported from the  dist  folder.","headings":[{"value":"Upgrade Guide","depth":1},{"value":"Upgrading to v3.0","depth":2},{"value":"Matrix API changes","depth":3},{"value":"Matrix transforms now return Arrays by default","depth":3},{"value":"Matrix setter functions no longer support ommitted parameters","depth":3},{"value":"Upgrading to v2.0","depth":2},{"value":"Upgrading to v1.1","depth":2},{"value":"Removed Functionality","depth":3}],"slug":"docs/upgrade-guide","title":"Upgrade Guide"},{"excerpt":"What's New v3.4 Release Date: Jan 7, 2020 @math.gl/geoid  - New module Support for  geoid -based  earth gravity models . New  Geoid  class calculates the height offset (aka \"undulation\") from the pure ellipsoid for a given lng/lat (using sherical harmonics). Geoid  instances can be initialized with PGM-encoded earth gravity model coefficient files from standard sources. @math.gl/polygon Support for flat arrays (e.g. polygons stored in typed arrays) Support for calling polygon utilities directly on arrays, without a  Polygon  instance. New function  modifyPolygonWindingDirection()  to modify polygon array winding direction in-place. v3.3 Release Date: Oct 9, 2020 @math.gl/proj4  - New module A new module supporting conversion between a wide range of geospatial coordinate reference systems specified e.g. using the OGC WKT-CRS specification. v3.2 Release Date: July 18, 2020 Typescript Typescript type definitions ( .d.ts  files) are now exported for all math.gl modules. @math.gl/polygon  - New module A new module offering geospatial polygon clipping functions. v3.1 Release date: Dec 16, 2019 @math.gl/web-mercator WebMercator projection support is now available through the new  @math.gl/web-mercator  npm sub-module. The  @math.gl/web-mercator  module is an evolution of the now archived  viewport-mercator-project  repository. v3.0 Release date: Aug 8, 2019 The 3.0 release brings support for geospatial math, culling, performance improvements, and some API consolidation. @math.gl/geospatial A new module (developed in collaboration with the Cesium engineering team) providing WebGL-framework-independent geospatial math classes and algorithms: New class  Ellipsoid  and constant  Ellipsoid.WGS84  for working with WSG84 coordinates @math.gl/culling A new module (developed in collaboration with the Cesium engineering team) providing WebGL-framework-independent classesthat support geometric intersection calculations (primarily intended to support frustum culling operations): New class  AxisAlignedBoundingBox New class  OrientedBoundingBox New class  BoundingSphere New class  CullingVolume @math.gl/core Transform API Consolidation The API for transformations (i.e. multiplying vectors with matrices or quaternions) has been extended and made more orthogonal: The  transform*  methods are now available on all  Vector  classes, in addition to on the  Matrix  classes. Among other things, this enables transformations without using  Matrix  classes. Naming consistency of transform methods across classes ( transform ,  transformAsPoint ,  transformAsVector ). Alternative transform methods added to the  Vector  classes ( transformByMatrix3 ,  transformByMatrix2 ,  transformByMatrix2x3  and  transformByQuaternion ). Simplifies using the most efficient transformation for the job. Matrix classes New methods  Matrix*.setColumn()  and  Matrix*.getColumn() New method  Matrix*.toString() Improved method:  Matrix4.frustum()  now supports infinite  far  plane (parity with  Matrix4.perspective , which already supported this). Utility Functions New: global functions  toRadians  and  toDegrees New: global function  exactEqual Performance Improvements  (and Website Benchmarks) A  benchmarking example  has been added to the website that makes it easy to assess the performance of the math.gl library on your own browser. The math.gl library has been carefully tuned based on these benchmarks and performance of the library has been significantly improved over version 2.x. v2.3 Release date: Jan 29, 2019 New class:  Matrix3 New: Add  scale  factor support to  Matrix3  and  Matrix4 Support quaternion to euler conversion Now uses the official  gl-matrix@3.0.0  package as dependency instead of forked gl-matrix packages. v2.2 Release date: Sep 20, 2018 Use  @babel/runtime  to reduce bundle size equals  function fix on arrays v2.0 Release date: June 25, 2018 New Naming Convention for Experimental Exports Experimental exports are now exported with a leading underscore ( _ ), instead of as members of the  experimental  namespace. The change was made to make it possible for tree-shaking bundlers to remove unused experimental exports from applications. v1.2 Release date: May 4, 2018 New  lerp  utility Experimental  Pose  class v1.1 Release date: April 16, 2018 Matrix4 Improvements Matrix4.orthographic()  - To simplify switching between perspective and orthographic views, math.gl now offers an additional method for creating orthographic projection matrix, that takes the same parameters as  Matrix4.perspective() , with the addition of one additional parameter,  focalDistance . See  Matrix4.orthographic ({fovy, aspect, focalDistance, near, far}) Bundle Size Reduction math.gl has been tuned to have approximately 20% smaller footprint when bundled in applications. THREE.js Compatibility math.gl classes now pass large parts of the THREE.js test suite, which should make it easier to reuse code written for the THREE.js math library. v1.0 Release date: Jan 9, 2018 Initial release.","headings":[{"value":"What's New","depth":1},{"value":"v3.4","depth":2},{"value":"v3.3","depth":2},{"value":"v3.2","depth":2},{"value":"v3.1","depth":2},{"value":"@math.gl/web-mercator","depth":3},{"value":"v3.0","depth":2},{"value":"@math.gl/geospatial","depth":3},{"value":"@math.gl/culling","depth":3},{"value":"@math.gl/core","depth":3},{"value":"v2.3","depth":2},{"value":"v2.2","depth":2},{"value":"v2.0","depth":2},{"value":"New Naming Convention for Experimental Exports","depth":3},{"value":"v1.2","depth":2},{"value":"v1.1","depth":2},{"value":"Matrix4 Improvements","depth":3},{"value":"Bundle Size Reduction","depth":3},{"value":"THREE.js Compatibility","depth":3},{"value":"v1.0","depth":2}],"slug":"docs/whats-new","title":"What's New"},{"excerpt":"Geospatial Models This section introduces some basic concepts used when modeling the Earth. The terminology and descriptions align with the WGS (World Geodetic System). Earth Models Earth Model Modeled By Description Sphere Web Mercator Earth is a sphere. Permits fast visualization. Mainly used in the web mercator projection to quickly project ellipsoidal coordinates on a flat surface, with less than 0.5% error. Ellipsoid WGS84 Earth is a (rotationally) flattened ellipsoid centered at Earth's center of gravity. This model is normally used to express WGS coordinates. Geoid Earth Gravity Model The shape that the ocean surface (extended through the continents) would take because of gravity and rotation of the Earth (ignoring winds, tides etc). It is a lumpy, roughly spherical object. Earth Gravity Models The Earth geoid can be calculated as an additive refinement of the elevation at each point on the ellipsoid. Model Resolution Size Notes EGM84-30 0.5 degrees Part of WGS84. Combined old GRS 80 with Doppler, satellite laser ranging and Very Long Baseline Interferometry (VLBI). EGM84 0.5 degrees . EGM96 15'x15' Airborne gravity surveys EGM2008 2.5'x2.5' GRACE  Satellite missions The additive refinement is calculated using spherical harmonics using big coefficent files. Newer models do provide additional precision, at the expense of considerable memory size for the coefficient files (and additional computational cost).","headings":[{"value":"Geospatial Models","depth":1},{"value":"Earth Models","depth":2},{"value":"Earth Gravity Models","depth":2}],"slug":"docs/developer-guide/geospatial-models","title":"Geospatial Models"},{"excerpt":"Get Started Installation If using a bundler like webpack to build your app with npm modules, use  npm  or  yarn  to install  @math.gl/core  and any other math.gl modules you need. Each math.gl module should come with 3 distributions. Normally the  esm  distribution will be selected by your bundler. For bundlers: dist/es5  - source tree fully transpiled to ES5 dist/esm  - source tree, fully transpiled to ES5 except  import/export  keywords are left for the bundler to enable tree shaking. dist/es6  - very lightly transpiled, mostly ES2020 to simplify debugging. TypeScript Type defintions are provided with each module. No need to install any separate types.","headings":[{"value":"Get Started","depth":1},{"value":"Installation","depth":2},{"value":"TypeScript","depth":2}],"slug":"docs/developer-guide/get-started","title":"Get Started"},{"excerpt":"@math.gl/web-mercator math.gl  is a suite of math modules for 3D and geospatial applications. This module contains utilities for perspective-enabled Web Mercator projections. For documentation please visit the  website .","headings":[{"value":"@math.gl/web-mercator","depth":1}],"slug":"modules/web-mercator","title":"@math.gl/web-mercator"},{"excerpt":"Overview The  @math.gl/web-mercator  module is the new home for the now archived viewport-mercator-project  repository, as of Oct 1, 2019. The  @math.gl/web-mercator  module offers projection and camera utilities supporting the spherical Web Mercator Projection. At its core, this is a utility for converting to and from map coordinates (i.e. latitude, longitude) to screen coordinates and back. Who is this for? Specifically built for use with  deck.gl  and  react-map-gl , but potentially useful for any web mapping application that wants to support perspective enabled Web Mercator Projections with floating point zoom levels. Example Usage The  WebMercatorViewport  class offers the equivalent of a 3D matrix \"camera\" class of the type you would find in any 3D/WebGL/OpenGL library.","headings":[{"value":"Overview","depth":1},{"value":"Who is this for?","depth":2},{"value":"Example Usage","depth":2}],"slug":"modules/web-mercator/docs","title":"Overview"},{"excerpt":"Web Mercator Coordinates Coordinates Description LngLat [lng, lat, alt]  on earth World [x, y, z]  on the Web Mercator plane Pixels [x, y, depth]  on screen LngLat Coordinates LngLat coordinates are specified in\n [longitude, latitude, elevation]  where longitude and latitude are in degrees from Greenwich meridian and the equator respectively, and altitude is in meters above sea level. Notes: Order is  [lng, lat]  (it can help to think of them as  [x, y]  to remember the order). lng goes from -180 to 180. lat goes from -85.051129 to 85.051129. The reason for the latitude cutoff is that the cylindrical mercator projection projects the earth sphere onto an infinitely tall strip, with the poles being projected at infinity. The reason that the cutoff is at ~85 degrees is that cutting off at this value makes the remaining projected area into a square (which at zoom 0 is projected onto 512x512 \"pixels\"). For details see e.g.  https://en.wikipedia.org/wiki/Web_Mercator . World Coordinates World coordinates specifies a location on the linear Web Mercator plane. Each unit is a \"pixel\" on the Web Mercator tile. It is unique for each lngLat location at a specific zoom level.  [x, y, z]  corresponds to  [longitude, latitude, elevation]  in the LngLat system. Pixel Coordinates Pixel coordinates specifies a point on screen in the format of  [x, y, z]  where x and y are in pixels on screen and  z  is pixel depth, normally between  -1  and  1 . By default, the pixel coordinate system of the viewport is defined with the origin in the top left, where the positive x-axis goes right, and the positive y-axis goes down. That is, the top left corner is  [0, 0]  and the bottom right corner is  [width - 1, height - 1] . The  project / unproject  functions have a flag that can reverse this convention. Additional Notes Per cartographic tradition, all angles including  latitude ,  longitude ,\n pitch  and  bearing  are specified in degrees, not radians. It is possible to query the PerspectiveMercatorViewport for a meters per pixel scale.\nNote that that distance scales are latitude dependent under\nweb mercator projection  see ,\nso scaling will depend on the viewport center and any linear scale factor\nshould only be expected to be locally correct.","headings":[{"value":"Web Mercator Coordinates","depth":1},{"value":"LngLat Coordinates","depth":3},{"value":"World Coordinates","depth":3},{"value":"Pixel Coordinates","depth":3},{"value":"Additional Notes","depth":3}],"slug":"modules/web-mercator/docs/developer-guide/about-coordinates","title":"Web Mercator Coordinates"},{"excerpt":"Accuracy of Offset Projection getDistanceScales  offers a cheap way to project lng/lat or meter offset to pixels. It is useful when using the GPU to project a cluster of coordinates near an origin point, without suffering the precision loss of WebGL. This article discusses the usage and accuracy of the distance scales. Meter offset to pixels Regular meter offset to pixels projection: When  getDistanceScales  is called with flag  highPrecision: true , it generates additional multipliers to compensate for precision loss over latitude change. More precise meter offset to pixels projection: Accuracy at San Francisco (37N, z = 12): R X unadjusted X adjusted 100 meters off by -0.000 pixels, 0.001% off by 0.000 pixels, 0.001% 1000 meters off by -0.008 pixels, 0.012% off by 0.000 pixels, 0.001% 5000 meters off by -0.200 pixels, 0.060% off by 0.002 pixels, 0.001% 10000 meters off by -0.804 pixels, 0.121% off by 0.003 pixels, 0.000% 30000 meters off by -7.277 pixels, 0.366% off by -0.021 pixels, 0.001% Accuracy at high latitude (75N, z = 12): R X unadjusted X adjusted 100 meters off by -0.001 pixels, 0.006% off by 0.000 pixels, 0.001% 1000 meters off by -0.130 pixels, 0.061% off by 0.001 pixels, 0.001% 5000 meters off by -3.290 pixels, 0.309% off by -0.001 pixels, 0.000% 10000 meters off by -13.200 pixels, 0.620% off by -0.044 pixels, 0.002% 30000 meters off by -119.884 pixels, 1.877% off by -1.473 pixels, 0.023% LngLat offset to pixels Regular lng_lat offset to pixels projection: When  getDistanceScales  is called with flag  highPrecision: true , it generates additional multipliers to compensate for precision loss over latitude change. More precise meter offset to pixels projection: Accuracy at San Francisco (37N, z = 12): R Y unadjusted Y adjusted 0.001 degrees off by -0.000 pixels, 0.001% off by -0.000 pixels, 0.000% 0.01 degrees off by -0.005 pixels, 0.007% off by -0.000 pixels, 0.000% 0.05 degrees off by -0.125 pixels, 0.034% off by -0.000 pixels, 0.000% 0.1 degrees off by -0.499 pixels, 0.068% off by -0.001 pixels, 0.000% 0.3 degrees off by -4.508 pixels, 0.204% off by -0.022 pixels, 0.001% Accuracy at high latitude (75N, z = 12): R Y unadjusted Y adjusted 0.001 degrees off by -0.001 pixels, 0.003% off by -0.000 pixels, 0.000% 0.01 degrees off by -0.081 pixels, 0.034% off by -0.000 pixels, 0.000% 0.05 degrees off by -2.038 pixels, 0.172% off by -0.005 pixels, 0.000% 0.1 degrees off by -8.172 pixels, 0.345% off by -0.039 pixels, 0.002% 0.3 degrees off by -74.258 pixels, 1.046% off by -1.055 pixels, 0.015%","headings":[{"value":"Accuracy of Offset Projection","depth":1},{"value":"Meter offset to pixels","depth":1},{"value":"LngLat offset to pixels","depth":1}],"slug":"modules/web-mercator/docs/developer-guide/offset-projection-accuracy","title":"Accuracy of Offset Projection"},{"excerpt":"Web Mercator Utility Functions lngLatToWorld(lngLat) Project a coordinate on sphere onto the 512x512 Web Mercator plane. Parameters: lngLat  (Array, required) - Specifies a point on the sphere to project.  [lng,lat]  in degrees. Returns: [x, y] worldToLngLat(xy, scale) Unproject a coordinate from the 512x512 Web Mercator plane back to the sphere. Parameters: xy  (Array, required) - Specifies a point on the Web Mercator tile to unproject.  [x, y]  in pixels. Returns: [lng, lat] worldToPixels(xyz, projectionMatrix) Project a coordinate from the Web Mercator coordinate system to screen. Parameters: xyz  (Array, required) - Specifies a point in the Web Mercator tile.  z  is the elevation and optional. projectionMatrix  (Matrix4, required) - The projection matrix. Returns: [x, y, z]  - coordinates on screen,  z  is the pixel depth. pixelsToWorld(xyz, unprojectionMatrix, targetZ) Project a coordinate from screen to the Web Mercator coordinate system. Parameters: xyz  (Array, required) - Specifies a point on screen.  z  is the pixel depth and optional. unprojectionMatrix  (Matrix4, required) - The unprojection matrix. targetZ  (Number, optional) - If pixel depth is not specified,  targetZ  is used as the elevation plane to unproject onto. Default  0 . Returns: [x, y, z]  - coordinates on the Web Mercator tile,  z  is the elevation. getMeterZoom(viewport) Returns the zoom level that gives a 1 meter pixel at a certain latitude. Parameters: viewport  (Object) - viewport props viewport.latitude  (Number, required) getDistanceScales(viewport) Calculate linear scales for quick conversion between meters/degrees/pixels distances around the given lat/lon. In mercator projection mode, the distance scales vary significantly with latitude. The scale is only reasonably accurate locally. Parameters: viewport  (Object) - viewport props viewport.longitude  (Number, required) viewport.latitude  (Number, required) viewport.highPrecision  (bool, optional) - default  false Returns: distanceScales  (Object) distanceScales.unitsPerMeter  (Array) - world units per meter in  [x, y, z] . distanceScales.metersPerUnit  (Array) - meters per world unit in  [x, y, z] distanceScales.unitsPerDegree  (Array) - world units per degree in  [x, y, z] distanceScales.degreesPerUnit  (Array) - degree per world unit in  [x, y, z] distanceScales.unitsPerMeter2  (Array) - if  highPrecision  is  true , returns world units per meter adjustment in  [x2, y2, z2] . It offers a cheap way to compensate for the precision loss with latitude. Amends  unitsPerMeter  by y offset (in meters):  [x + x2 * dy, y + y2 * dy, z + z2 * dy] . distanceScales.unitsPerDegree2  (Array) - if  highPrecision  is  true , returns world units per degree adjustment in  [x2, y2, z2] . It offers a cheap way to compensate for the precision loss with latitude. Amends  unitsPerDegree  by y offset (in degrees):  [x + x2 * dy, y + y2 * dy, z + z2 * dy] . addMetersToLngLat(lngLatZ, xyz) Offset a spherical position by meters. Parameters: lngLatZ  (Array) - origin in  [lng, lat, alt] . Altitude is optional. xyz  (Array) - offset from the origin  [x, y, z]  in meters.  x  is easting and  y  is northing.  z  is optional. Returns: [lng, lat]  if the third component in neither argument is specified, or [lng, lat, alt]  otherwise. getViewMatrix(viewport) Get a transform matrix that projects from the mercator (pixel) space into the camera (view) space. Centers the map at the given coordinates. Parameters: viewport  (Object) - viewport props viewport.height  (Number, required) viewport.pitch  (Number, required) viewport.bearing  (Number, required) viewport.scale  (Number, required) viewport.altitude  (Number, required) viewport.center  (Array, optional) - pre-calculated world position of map center using  getWorldPosition . Default  [0, 0] . Returns: viewMatrix  (Array) 4x4 matrix. getProjectionMatrix(viewport) Get a transform matrix that projects from camera (view) space to clipspace. Parameters: viewport  (Object) - viewport props viewport.width  (Number, required) viewport.height  (Number, required) viewport.pitch  (Number, required) viewport.altitude  (Number, required) viewport.nearZMultiplier  (Number, optional) - near plane multiplier. Default  1 . viewport.farZMultiplier  (Number, optional) - far plane multiplier. Default  1 Notes: To match Mapbox's z-buffer, use these parameters: Before 0.29: nearZMultiplier :  0.1 farZMultiplier :  1 Starting 0.29: nearZMultiplier :  1 / viewport.height farZMultiplier :  1.01 getProjectionParameters({width, height, altitude, pitch, farZMultiplier}}) Parameters: width  (Number, required) height  (Number, required) pitch  (Number, required) altitude  (Number, required) farZMultiplier  (Number, optional) - near plane multiplier. Default  1 . farZMultiplier  (Number, optional) - far plane multiplier. Default  1 . Returns Object with  {fovy, aspect, focalDistance, near, far}  fields. fitBounds(opts) Returns map settings (longitude, latitude and zoom) that will contain the provided corners within the provided dimensions. Only supports non-perspective mode. Parameters: opts  (Object) - options opts.width  (Number, required) opts.height  (Number, required) opts.bounds  (Array, required) - opposite corners specified as  [[lon, lat], [lon, lat]] opts.minExtent  (Number, optional) - If supplied, the bounds used to calculate the new map settings will be expanded if the delta width or height of the supplied  bounds  is smaller than this value. opts.maxZoom = 24  (Number, optional) - The returned zoom value will be capped to this value. Avoids returning infinite  zoom  when the supplied  bounds  have zero width or height deltas. opts.padding = 0  (Number, optional) - the amount of padding in pixels to add to the given bounds. opts.offset = [0,0]  (Array, optional) - the center of the given bounds relative to the map's center,  [x, y]  measured in pixels. Returns: {longitude, latitude, zoom} Notes: minExtent  - Note that this value represents delta latitude/longitudes and value of  0.01  would roughly represent 1km. normalizeViewportProps(viewport) This will adjust the map center and zoom so that the projected map fits into the target viewport size without white gaps. Parameters: viewport  (Object) viewport.width  (Number, required) viewport.height  (Number, required) viewport.longitude  (Number, required) viewport.latitude  (Number, required) viewport.zoom  (Number, required) viewport.pitch  (Number, optional) Returns: viewport  - normalized  {width, height, longitude, latitude, zoom, pitch, bearing} flyToViewport(startProps, endProps, t, opts) While flying from one viewport to another, returns in-transition viewport props at a given time. This util function implements the algorithm described in “Smooth and efficient zooming and panning.” by Jarke J. van Wijk and Wim A.A. Nuij. Parameters: startProps  (Object) - viewport to fly from startProps.width  (Number, required) startProps.height  (Number, required) startProps.longitude  (Number, required) startProps.latitude  (Number, required) startProps.zoom  (Number, required) endProps  (Object) - viewport to fly from endProps.longitude  (Number, required) endProps.latitude  (Number, required) endProps.zoom  (Number, required) t  (Number) - a time factor between 0 and 1.  0  indicates the start of the transition,  1  indicates the end of the transition. opts  (Object, optional) opts.curve  (Number, optional, default: 1.414) - The zooming \"curve\" that will occur along the flight path, . Returns: {longitude, latitude, zoom} getFlyToDuration(startProps, endProps, opts) Returns time in milliseconds, that is required perform transition from one viewport to another. Time returned is proportional to the distance we are transitioning to. This util function implements mapbox-gl-js ( https://docs.mapbox.com/mapbox-gl-js/api/#map#flyto ) duration calculation. Parameters: startProps  (Object) - viewport to fly from startProps.width  (Number, required) startProps.height  (Number, required) startProps.longitude  (Number, required) startProps.latitude  (Number, required) startProps.zoom  (Number, required) endProps  (Object) - viewport to fly from endProps.longitude  (Number, required) endProps.latitude  (Number, required) endProps.zoom  (Number, required) opts  (Object, optional) - optional parameters that effect duration calculation. opts.curve  (Number, optional, default: 1.414) - The zooming \"curve\" that will occur along the flight path. opts.speed  (Number, optional, default: 1.2) - The average speed of the animation defined in relation to  options.curve , it linearly affects the duration, higher speed returns smaller durations and vice versa. opts.screenSpeed  (Number, optional) - The average speed of the animation measured in screenfuls per second. Similar to  opts.speed  it linearly affects the duration, when specified  opts.speed  is ignored. opts.maxDuration  (Number, optional) - Maximum duration in milliseconds, if calculated duration exceeds this value,  0  is returned. Returns: duration  Number, in milliseconds.","headings":[{"value":"Web Mercator Utility Functions","depth":1},{"value":"lngLatToWorld(lngLat)","depth":3},{"value":"worldToLngLat(xy, scale)","depth":3},{"value":"worldToPixels(xyz, projectionMatrix)","depth":3},{"value":"pixelsToWorld(xyz, unprojectionMatrix, targetZ)","depth":3},{"value":"getMeterZoom(viewport)","depth":3},{"value":"getDistanceScales(viewport)","depth":3},{"value":"addMetersToLngLat(lngLatZ, xyz)","depth":3},{"value":"getViewMatrix(viewport)","depth":3},{"value":"getProjectionMatrix(viewport)","depth":3},{"value":"getProjectionParameters({width, height, altitude, pitch, farZMultiplier}})","depth":3},{"value":"fitBounds(opts)","depth":3},{"value":"normalizeViewportProps(viewport)","depth":3},{"value":"flyToViewport(startProps, endProps, t, opts)","depth":3},{"value":"getFlyToDuration(startProps, endProps, opts)","depth":3}],"slug":"modules/web-mercator/docs/api-reference/web-mercator-utils","title":"Web Mercator Utility Functions"},{"excerpt":"WebMercatorViewport The  WebMercatorViewport  class takes map camera states ( latitude ,  longitude ,  zoom ,  pitch ,  bearing  etc.),\nand performs projections between world and screen coordinates. Constructor Parameter Type Default Description width number 1 Width of viewport height number 1 Height of viewport latitude number 0 Latitude of viewport center longitude number 0 Longitude of viewport center zoom number 11 Map zoom (scale is calculated as  2^zoom ) pitch number 0 The pitch (tilt) of the map from the screen, in degrees (0 is straight down) bearing number 0 The bearing (rotation) of the map from north, in degrees counter-clockwise (0 means north is up) altitude number 1.5 Altitude of camera in screen units Remarks: Altitude has a default value that matches assumptions in mapbox-gl width  and  height  are forced to 1 if supplied as 0, to avoid\ndivision by zero. This is intended to reduce the burden of apps to\nto check values before instantiating a  Viewport . When using Mercator projection, per cartographic tradition, longitudes and\nlatitudes are specified as degrees. Methods project(lngLatZ, options) Projects latitude and longitude to pixel coordinates on screen. Parameter Type Default Description lngLatZ Array (required) map coordinates,  [lng, lat]  or  [lng, lat, Z]  where  Z  is elevation in meters options Object {} named options options.topLeft Boolean true If  true  projected coords are top left, otherwise bottom left Returns:  [x, y]  or  [x, y, z]  in pixels coordinates.  z  is pixel depth. If input is  [lng, lat] : returns  [x, y] . If input is  [lng, lat, Z] : returns  [x, y, z] . Remarks: By default, returns top-left coordinates suitable for canvas/SVG type\nrendering. unproject(xyz, options) Unproject pixel coordinates on screen to longitude and latitude on map. Parameter Type Default Description xyz Array (required) pixel coordinates,  [x, y]  or  [x, y, z]  where  z  is pixel depth options Object {} named options options.topLeft Boolean true If  true  projected coords are top left, otherwise bottom left options.targetZ number 0 If pixel depth  z  is not specified in  xyz , use  options.targetZ  as the desired elevation Returns:  [lng, lat]  or  [longitude, lat, Z]  in map coordinates.  Z  is elevation in meters. If input is  [x, y]  without specifying  options.targetZ : returns  [lng, lat] . If input is  [x, y]  with  options.targetZ : returns  [lng, lat, targetZ] . If input is  [x, y, z] : returns  [lng, lat, Z] . projectFlat(lngLat, scale) Project longitude and latitude onto Web Mercator coordinates. Parameter Type Default Description lngLat Array (required) map coordinates,  [lng, lat] scale number this.scale Web Mercator scale Returns: [x, y] , representing Web Mercator coordinates. unprojectFlat(xy, scale) Unprojects a Web Mercator coordinate to longitude and latitude. Parameter Type Default Description xy Array (required) Web Mercator coordinates,  [x, y] scale number this.scale Web Mercator scale Returns: [longitude, latitude] getBounds(options) Get the axis-aligned bounding box of the current visible area. options.z  (number, optional) - To calculate a bounding volume for fetching 3D data, this option can be used to get the bounding box at a specific elevation. Default  0 . Returns: [[lon, lat], [lon, lat]]  as the south west and north east corners of the smallest orthogonal bounds that encompasses the visible region. getBoundingRegion(options) Get the vertices of the current visible region. options.z  (number, optional) - To calculate a bounding volume for fetching 3D data, this option can be used to get the bounding region at a specific elevation. Default  0 . Returns: An array of 4 corners in  [longitude, latitude, altitude]  that define the visible region. fitBounds(bounds, options: object) Get a new flat viewport that fits around the given bounding box. bounds  ([ number,number , number,number ]) - an array of two opposite corners of\nthe bounding box. Each corner is specified in  [lon, lat] . options.padding  (number|{top:number, bottom: number, left: number, right: number}, optional) - The amount of\npadding in pixels to add to the given bounds from the edge of the viewport. If padding is set as object, all parameters are\nrequired. options.offset  ( number,number , optional) - The center of the given bounds relative to the viewport's center,  [x, y]  measured in pixels. opts.minExtent  (number, optional) - If supplied, the bounds used to calculate the new map settings will be expanded if the delta width or height of the supplied  bounds  is smaller than this value. opts.maxZoom = 24  (number, optional) - The returned zoom value will be capped to this value. Avoids returning infinite  zoom  when the supplied  bounds  have zero width or height deltas. Returns: A new  WebMercatorViewport  instance getMapCenterByLngLatPosition(options: object): [number, number] Get the map center that place a given  lng, lat  coordinate at screen point  x, y . Parameters: options.lngLat  (Array, required) -  lng,lat  coordinates of a location on the sphere. options.pos  (Array, required) -  x,y  coordinates of a pixel on screen. Returns: [longitude, latitude]  as the new map center","headings":[{"value":"WebMercatorViewport","depth":1},{"value":"Constructor","depth":2},{"value":"Methods","depth":2},{"value":"project(lngLatZ, options)","depth":5},{"value":"unproject(xyz, options)","depth":5},{"value":"projectFlat(lngLat, scale)","depth":5},{"value":"unprojectFlat(xy, scale)","depth":5},{"value":"getBounds(options)","depth":5},{"value":"getBoundingRegion(options)","depth":5},{"value":"fitBounds(bounds, options: object)","depth":5},{"value":"getMapCenterByLngLatPosition(options: object): [number, number]","depth":5}],"slug":"modules/web-mercator/docs/api-reference/web-mercator-viewport","title":"WebMercatorViewport"},{"excerpt":"Overview @math.gl/sun  is a tiny JavaScript library for calculating sun position for the given location and time. Installation Usage Attribution This module is a fork of @mourner's  SunCalc  under BSD 2-clause license.","headings":[{"value":"Overview","depth":1},{"value":"Installation","depth":2},{"value":"Usage","depth":2},{"value":"Attribution","depth":2}],"slug":"modules/sun/docs","title":"Overview"},{"excerpt":"getSun TBA","headings":[{"value":"getSun","depth":1}],"slug":"modules/sun/docs/api-reference/get-sun","title":"getSun"},{"excerpt":"@math.gl/sun math.gl  is a suite of math modules for 3D and geospatial applications. This module contains math to calculate sun positions. For documentation please visit the  website .","headings":[{"value":"@math.gl/sun","depth":1}],"slug":"modules/sun","title":"@math.gl/sun"},{"excerpt":"getSunDirection TBA","headings":[{"value":"getSunDirection","depth":1}],"slug":"modules/sun/docs/api-reference/get-sun-direction","title":"getSunDirection"},{"excerpt":"@math.gl/proj4 math.gl  is a suite of math modules for 3D and geospatial applications. This module contains support for conversion between geospatial coordinate systems. For documentation please visit the  website .","headings":[{"value":"@math.gl/proj4","depth":1}],"slug":"modules/proj4","title":"@math.gl/proj4"},{"excerpt":"Proj4Projection Usage Reproject WGS84 coordinates to another CRS Define Projection Aliases Static Fields Proj4Projection.defineProjectionAliases(projections: { alias: string : string}); Defines projection aliases Methods constructor(options: {from?: string, to?: string}) Create a new  Proj4Projection  instance that can convert between the specified coordinate systems. project(coord: number[]): number[] Project a coordinate project from first to second coordinate system unproject(coord: number[]): number[] Project a coordinate project from second to first coordinate system","headings":[{"value":"Proj4Projection","depth":1},{"value":"Usage","depth":2},{"value":"Static Fields","depth":2},{"value":"Proj4Projection.defineProjectionAliases(projections: {alias: string: string});","depth":3},{"value":"Methods","depth":2},{"value":"constructor(options: {from?: string, to?: string})","depth":3},{"value":"project(coord: number[]): number[]","depth":3},{"value":"unproject(coord: number[]): number[]","depth":3}],"slug":"modules/proj4/docs/api-reference/proj4-projection","title":"Proj4Projection"},{"excerpt":"@math.gl/polygon math.gl  is a suite of math modules for 3D applications. This module contains utilities that work with polylines and polygons. For documentation please visit the  website .","headings":[{"value":"@math.gl/polygon","depth":1}],"slug":"modules/polygon","title":"@math.gl/polygon"},{"excerpt":"Overview Installation Usage","headings":[{"value":"Overview","depth":1},{"value":"Installation","depth":2},{"value":"Usage","depth":2}],"slug":"modules/polygon/docs","title":"Overview"},{"excerpt":"clipPolyline Clips a polyline with a bounding box. The clipping bounds are defined as an orthoganal rectangle on the XY plane. If a 3D polyline is supplied, it is clipped by the extuded volume from the bounding box. Usage Arguments: positions  (Array|TypedArray) - a flat array of the vertex positions that define the polyline. bbox  (Array) - the bounding box, in  [minX, minY, maxX, maxY] options  (Object, optional) size  (Number) - the number of elements in each vertex. Size  2  will interpret  positions  as  [x0, y0, x1, y1, ...]  and size  3  will interpret  positions  as  [x0, y0, z0, x1, y1, z1, ...] . Default  2 . startIndex  (Number, optional) - the index in  positions  to start reading vertices. Default  0 . endIndex  (Number, optional) - the index in  positions  to stop reading vertices. Default  positions.length . Returns: An array of polylines that are parts of the original polyline and contained by the given bounding box. Each polyline is represented by a positions array that uses the same vertex size as the input. If the input polyline is entirely outside of the bounding box, an empty array will be returned.","headings":[{"value":"clipPolyline","depth":1},{"value":"Usage","depth":2}],"slug":"modules/polygon/docs/api-reference/clip-polyline","title":"clipPolyline"},{"excerpt":"Overview The  @math.gl/proj4  module provides support for conversion between major geospatial coordinate reference systems (CRS) and projections used with computer maps, such as: WGS84  (World Geodetic System) coordinates. Web Mercator Projection Classes Class Description Proj4Projection A projection class Usage Reproject WGS84 coordinates to another CRS Geospatial Coordinate Systems There are an infinite number of possible coordinate systems; therefore strict syntax is required to describe the parameters of any given CRS. Two main systems are supported in this module: Proj4 strings and WKT strings. Within WKT there exists both OGC WKT and ESRI WKT syntax; both are generally supported though some more-obscure projection keywords may not be used. Note that Proj4 strings  can be slightly more accurate  in some circumstances than WKT strings. There are thousands of named \"EPSG\" projections. This module only includes aliases for those in the section below by default. To use a different EPSG projection, you can use  https://epsg.io . For example,  https://epsg.io/4326  defines standard longitude-latitude coordinates and lists multiple projection strings. Choose one of the  OGC WKT ,  ESRI WKT , or  PROJ.4  strings listed. The epsg.io website also has a public API, e.g., for WGS 84:  https://epsg.io/?q=4326&format=json If you already know the EPSG identifier, you can make the API request even simpler by adding the desired extension to your url: Aliases Note that Proj4Projection allows aliases to be defined and comes with the following pre-installed aliases. Coordinate system Aliases Lat/lon, WGS84 datum EPSG:4326 ,  WGS84 Lat/lon, NAD83 datum EPSG:4269 Web mercator EPSG:3857 ,  EPSG:3785 ,  GOOGLE ,  EPSG:900913 ,  EPSG:102113 References OGC WKT-CRS Specification  standards documentation. spatialreference.org  a catalog of coordinate system references. espg.io  Lets the user look up the definition of a coordinate system. E.g.  https://epsg.io/4326  provides the definition of WGS84 in WKT-CRS format: Attribution This module is a wrapper around  proj4js , which has a permissive  license . A part of the  MetaCRS  libraries.","headings":[{"value":"Overview","depth":1},{"value":"Classes","depth":2},{"value":"Usage","depth":2},{"value":"Geospatial Coordinate Systems","depth":2},{"value":"Aliases","depth":3},{"value":"References","depth":3},{"value":"Attribution","depth":2}],"slug":"modules/proj4/docs","title":"Overview"},{"excerpt":"clipPolygon Clips a polygon with a bounding box. The clipping bounds are defined as an orthoganal rectangle on the XY plane. If a 3D polygon is supplied, it is clipped by the extuded volume from the bounding box. Usage Arguments: positions  (Array|TypedArray) - a flat array of the vertex positions that define the polygon. bbox  (Array) - the bounding box, in  [minX, minY, maxX, maxY] options  (Object, optional) size  (Number) - the number of elements in each vertex. Size  2  will interpret  positions  as  [x0, y0, x1, y1, ...]  and size  3  will interpret  positions  as  [x0, y0, z0, x1, y1, z1, ...] . Default  2 . startIndex  (Number, optional) - the index in  positions  to start reading vertices. Default  0 . endIndex  (Number, optional) - the index in  positions  to stop reading vertices. Default  positions.length . Returns: A positions array that describes the intersection of the original polygon and the bounding box. Uses the same vertex size as the input. If the input polygon does not overlap with the bounding box, an empty array will be returned.","headings":[{"value":"clipPolygon","depth":1},{"value":"Usage","depth":2}],"slug":"modules/polygon/docs/api-reference/clip-polygon","title":"clipPolygon"},{"excerpt":"cutPolygonByGrid Subdivides a polygon by intersecting with a uniform grid. Usage Arguments: positions  (Array|TypedArray) - a flat array of the vertex positions that define the polygon's rings. holeIndices  (Array) - the indices in  positions  where each hole starts. If  null , the polygon has no holes. options  (Object, optional) size  (Number) - the number of elements in each vertex. Size  2  will interpret  positions  as  [x0, y0, x1, y1, ...]  and size  3  will interpret  positions  as  [x0, y0, z0, x1, y1, z1, ...] . Default  2 . gridResolution  (Number, optional) - the grid size. Default  10 . gridOffset  (Array, optional) - the grid offset in  [x, y] . Default  [0, 0]  i.e. the grid starts from the coordinate origin. edgeTypes  (Boolean) - if  true , returns an additional array for each polygon that describes the nature of each vertex. See \"returns\" below. Returns: An array of polygons. Each polygons is represented by an object with the following fields: positions  (Array) - a flat array of the vertex positions that define the polygon's rings. holeIndices  (Array) - the indices in  positions  where each hole starts. Not present if the polygon has no holes. edgeTypes  (Array) - describes the nature of each vertex in  positions : 0  - the segment connecting this vertex to the next is inside the original polygon 1  - the segment connecting this vertex to the next is on the border of the original polygon","headings":[{"value":"cutPolygonByGrid","depth":1},{"value":"Usage","depth":2}],"slug":"modules/polygon/docs/api-reference/cut-polygon-by-grid","title":"cutPolygonByGrid"},{"excerpt":"cutPolygonByMercatorBounds Splits a geospatial polygon at the  180th meridian  and the top ( latitude=90 ) and bottom ( latitude=-90 ) edges of the Web Mercator map. Usage Arguments: positions  (Array|TypedArray) - a flat array of the vertex positions that define the polygon's rings.  x  is longitude in degrees, and  y  is latitude in degrees. holeIndices  (Array) - the indices in  positions  where each hole starts. If  null , the polygon has no holes. options  (Object, optional) size  (Number) - the number of elements in each vertex. Size  2  will interpret  positions  as  [x0, y0, x1, y1, ...]  and size  3  will interpret  positions  as  [x0, y0, z0, x1, y1, z1, ...] . Default  2 . normalize  (Boolean) - make sure the output longitudes are within  [-180, 180] . Default  true . maxLatitude  (Number) - since latitude=90 projects to infinity in Web Mercator projection,  maxLatitude  will be used to represent the pole. Default  85.051129  which makes the map square. edgeTypes  (Boolean) - if  true , returns an additional array for each polygon that describes the nature of each vertex. See \"returns\" below. Returns: An array of polygons. Each polygons is represented by an object with the following fields: positions  (Array) - a flat array of the vertex positions that define the polygon's rings. holeIndices  (Array) - the indices in  positions  where each hole starts. Not present if the polygon has no holes. edgeTypes  (Array) - describes the nature of each vertex in  positions : 0  - the segment connecting this vertex to the next is inside the original polygon 1  - the segment connecting this vertex to the next is on the border of the original polygon","headings":[{"value":"cutPolygonByMercatorBounds","depth":1},{"value":"Usage","depth":2}],"slug":"modules/polygon/docs/api-reference/cut-polygon-by-mercator-bounds","title":"cutPolygonByMercatorBounds"},{"excerpt":"cutPolylineByGrid Subdivides a polyline by intersecting with a uniform grid. Usage Arguments: positions  (Array|TypedArray) - a flat array of the vertex positions that define the polyline. options  (Object, optional) size  (Number) - the number of elements in each vertex. Size  2  will interpret  positions  as  [x0, y0, x1, y1, ...]  and size  3  will interpret  positions  as  [x0, y0, z0, x1, y1, z1, ...] . Default  2 . startIndex  (Number, optional) - the index in  positions  to start reading vertices. Default  0 . endIndex  (Number, optional) - the index in  positions  to stop reading vertices. Default  positions.length . gridResolution  (Number, optional) - the grid size. Default  10 . gridOffset  (Array, optional) - the grid offset in  [x, y] . Default  [0, 0]  i.e. the grid starts from the coordinate origin. broken  (Boolean, optional) - if  true , the polyline is broken into multiple polylines at the subdivision points. If  false , subdivision points are inserted into the original polyline. Default  false . Returns: A polyline or an array of polylines, depending on the  broken  option. Each polyline is represented by a positions array that uses the same vertex size as the input.","headings":[{"value":"cutPolylineByGrid","depth":1},{"value":"Usage","depth":2}],"slug":"modules/polygon/docs/api-reference/cut-polyline-by-grid","title":"cutPolylineByGrid"},{"excerpt":"cutPolylineByMercatorBounds Splits a geospatial polyline at the  180th meridian . Usage Arguments: positions  (Array|TypedArray) - a flat array of the vertex positions that define the polyline.  x  is longitude in degrees, and  y  is latitude in degrees. options  (Object, optional) size  (Number) - the number of elements in each vertex. Size  2  will interpret  positions  as  [x0, y0, x1, y1, ...]  and size  3  will interpret  positions  as  [x0, y0, z0, x1, y1, z1, ...] . Default  2 . startIndex  (Number, optional) - the index in  positions  to start reading vertices. Default  0 . endIndex  (Number, optional) - the index in  positions  to stop reading vertices. Default  positions.length . normalize  (Boolean) - make sure the output longitudes are within  [-180, 180] . Default  true . Returns: An array of polylines. Each polyline is represented by a positions array that uses the same vertex size as the input.","headings":[{"value":"cutPolylineByMercatorBounds","depth":1},{"value":"Usage","depth":2}],"slug":"modules/polygon/docs/api-reference/cut-polyline-by-mercator-bounds","title":"cutPolylineByMercatorBounds"},{"excerpt":"polygon-utils A set of polygon-related utility functions. Utility functions are available for flat arrays and for arrays of points. Note: the  * Points set of functions is used for arrays of points, and is separated for performance and backwards compatibility reasons. Usage Types PolygonParams PolygonParams Fields: start  (number) - Start index of the polygon in the array of positions. Defaults to 0. end  (number) - End index of the polygon in the array of positions. Defaults to number of positions. size  (Number) - Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays. isClosed  (Boolean) - Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited. Functions modifyPolygonWindingDirection Checks winding direction of the polygon and reverses the polygon in case if opposite winding direction. Note: points are modified in-place. modifyPolygonWindingDirection(points, direction, params) Arguments: points  (Array|TypedArray) - a flat array of the points that define the polygon. direction  (Number) - Requested winding direction. A positive 1 for clockwise, -1 for counter clockwise. options  (PolygonParams) - Polygon parameters. Returns: Returns true if the winding direction was changed. getPolygonSignedArea Returns signed area of the polygon. getPolygonSignedArea(points, options) Arguments: points  (Array|TypedArray) - a flat array of the points that define the polygon. options  (PolygonParams) - Polygon parameters. Returns: Signed area of the polygon. getPolygonWindingDirection Returns winding direction of the polygon. getPolygonWindingDirection(points, options) Arguments: points  (Array|TypedArray) - a flat array of the points that define the polygon. options  (PolygonParams) - Polygon parameters. Returns: A positive number is clockwise. A negative number is counter clockwise. forEachSegmentInPolygon Calls visitor callback for each segment in the polygon. forEachSegmentInPolygon(points, (p1x, p1y, p2x, p2y, ind1, ind2) => ...), options Arguments: points  (Array[]|TypedArray[]) - a flat array of the points that define the polygon. visitor  (SegmentVisitorFlat) - a callback to call for each segment of the polygon. options  (PolygonParams) - Polygon parameters. modifyPolygonWindingDirectionPoints Checks winding direction of the polygon and reverses the polygon in case if opposite winding direction. Note: points are modified in-place. modifyPolygonWindingDirectionPoints(points, direction, options) Arguments: points  (Array[]|TypedArray[]) - an array of the points that define the polygon. direction  (Number) - Requested winding direction. A positive 1 for clockwise, -1 for counter clockwise. options  (PolygonParams) - Polygon parameters. Returns: Returns true if the winding direction was changed. getPolygonSignedAreaPoints Returns signed area of the polygon. getPolygonSignedAreaPoints(points, options) Arguments: points  (Array[]|TypedArray[]) - an array of the points that define the polygon. options  (PolygonParams) - Polygon parameters. Returns: Signed area of the polygon. getPolygonWindingDirectionPoints Returns winding direction of the polygon. getPolygonWindingDirectionPoints(points, options) Arguments: points  (Array[]|TypedArray[]) - an array of the points that define the polygon. options  (PolygonParams) - Polygon parameters. Returns: A positive number is clockwise. A negative number is counter clockwise. forEachSegmentInPolygonPoints Calls visitor callback for each segment in the polygon. forEachSegmentInPolygonPoints(points, (p1, p2, ind1, ind2) => ..., options) Arguments: points  (Array[]|TypedArray[]) - an array of the points that define the polygon. visitor  (SegmentVisitor) - a callback to call for each segment of the polygon. options  (PolygonParams) - Polygon parameters.","headings":[{"value":"polygon-utils","depth":1},{"value":"Usage","depth":2},{"value":"Types","depth":2},{"value":"PolygonParams","depth":3},{"value":"Functions","depth":2},{"value":"modifyPolygonWindingDirection","depth":3},{"value":"getPolygonSignedArea","depth":3},{"value":"getPolygonWindingDirection","depth":3},{"value":"forEachSegmentInPolygon","depth":3},{"value":"modifyPolygonWindingDirectionPoints","depth":3},{"value":"getPolygonSignedAreaPoints","depth":3},{"value":"getPolygonWindingDirectionPoints","depth":3},{"value":"forEachSegmentInPolygonPoints","depth":3}],"slug":"modules/polygon/docs/api-reference/polygon-utils","title":"polygon-utils"},{"excerpt":"Polygon Allows an array of points (whether closed or non-closed) to be treated as a Polygon. Implements the  Shoelace formula  for determining the area and winding direction of an arbitrary polygon. Usage Methods constructor Creates a new Polygon object. The polygon object will reference the provided points, assuming them to not be modified for the lifetime of the Polygon object. getSignedArea Returns the area with a sign indicating the winding direction. polygon.getSignedArea() getArea polygon.getArea() Note: A convenience method that returns  Math.abs(polygon.getSignedArea()) . getWindingDirection Returns the direction of the polygon path. polygon.getWindingDirection() A positive number is clockwise. A negative number is counter clockwise. Note: A convenience method that returns  Math.sign(polygon.getSignedArea()) forEachSegment Lets the application iterate over each segment. polygon.forEachSegment((p1, p2) => ...); modifyWindingDirection Checks winding direction of the polygon and reverses the polygon in case if opposite winding direction. Note: points of the polygon are modified in-place. A positive number is clockwise. A negative number is counter clockwise. polygon.modifyWindingDirection(direction); Returns: Returns true if the winding direction was changed. Remarks To avoid having to copy a non-closed path to be able to treat it as a polygon (by adding a copy of the first vertex to then end of the path),\ninstead we define a  forEachSegment  iteration method that makes sure the last segment is iterated over.","headings":[{"value":"Polygon","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"getSignedArea","depth":3},{"value":"getArea","depth":3},{"value":"getWindingDirection","depth":3},{"value":"forEachSegment","depth":3},{"value":"modifyWindingDirection","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/polygon/docs/api-reference/polygon","title":"Polygon"},{"excerpt":"math.gl This is a legacy module that should not be used in new applications.  math.gl  module has been renamed to  @math.gl/core . math.gl  is a suite of math modules for 3D applications. This module is a wrapper for  @math.gl/core , that contains classes for vectors and matrices etc. For documentation please visit the  website .","headings":[{"value":"math.gl","depth":1}],"slug":"modules/main","title":"math.gl"},{"excerpt":"@math.gl/geospatial math.gl  is a suite of math modules for 3D and geospatial applications. This module contains geospatial math, primarly ellipsoid math for dealing with the WGS84 (World Geodetic System) coordinate system. For documentation please visit the  website .","headings":[{"value":"@math.gl/geospatial","depth":1}],"slug":"modules/geospatial","title":"@math.gl/geospatial"},{"excerpt":"Overview The  @math.gl/geospatial  module provides support for ellipsoidal math, focusing on geospatial use cases. It provides classes and utilities to facilitate working with ellipsoidal geospatial coordinate systems and projections used with computer maps, primarily  WGS84  (World Geodetic System) coordinates. Classes Class Description Ellipsoid Implements ellipsoid Ellipsoid.WSG84 An  Ellipsoid  instance initialized with Earth radii per WGS84. Usage Examples A major use of this library is to convert between \"cartesian\" ( x ,  y ,  z ) and \"cartographic\" ( longitude ,  latitude ,  height ) representations of WSG84 coordinates. The  Ellipsoid  class implements these calculations. Usage Determine the Cartesian representation of a Cartographic position on a WGS84 ellipsoid. Determine the Cartographic representation of a Cartesian position on a WGS84 ellipsoid. Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame. Framework Independence Like all non-core math.gl modules, this module can be used independently of core math.gl classes. Any input or result vectors can be supplied as JavaScript  Array  instances of length 3, or objects with  x ,  y ,  z  elements. History This library was initially created as part of a bigger collaboration between the vis.gl and Cesium teams to provide framework-independent, portable support for the 3D Tiles specification, however it has been designed to provide generic support for WGS84 and ellipsoidal math. Attribution This code is a fork of selected classes in the  Cesium  code base, under the Apache 2 License.","headings":[{"value":"Overview","depth":1},{"value":"Classes","depth":2},{"value":"Usage Examples","depth":2},{"value":"Usage","depth":2},{"value":"Framework Independence","depth":2},{"value":"History","depth":2},{"value":"Attribution","depth":2}],"slug":"modules/geospatial/docs","title":"Overview"},{"excerpt":"Ellipsoid A quadratic surface defined in Cartesian coordinates by the equation  (x / a)^2 + (y / b)^2 + (z / c)^2 = 1 . Primarily used to represent the shape of planetary bodies. The main use of this class is to convert between the \"cartesian\" and \"cartographic\" coordinate systems. Rather than constructing this object directly, one of the provided constants is used. Usage Determine the Cartesian representation of a Cartographic position on a WGS84 ellipsoid. Determine the Cartographic representation of a Cartesian position on a WGS84 ellipsoid. Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame. Static Fields Ellipsoid.WGS84 : Ellipsoid (readonly) An Ellipsoid instance initialized to the WGS84 standard. Members radii : Vector3 (readonly) Gets the radii of the ellipsoid. radiiSquared : Vector3 (readonly) Gets the squared radii of the ellipsoid. radiiToTheFourth : Vector3 (readonly) Gets the radii of the ellipsoid raise to the fourth power. oneOverRadii : Vector3 (readonly) Gets one over the radii of the ellipsoid. oneOverRadiiSquared : Vector3 (readonly) Gets one over the squared radii of the ellipsoid. minimumRadius : Number (readonly) Gets the minimum radius of the ellipsoid. maximumRadius : Number Gets the maximum radius of the ellipsoid. Methods constructor(x : Number, y : Number, z : Number) x = 0  The radius in the x direction. y = 0  The radius in the y direction. z = 0  The radius in the z direction. Throws All radii components must be greater than or equal to zero. clone() : Ellipsoid Duplicates an Ellipsoid instance. {Ellipsoid}  result  Optional object onto which to store the result, or undefined if a new\ninstance should be created. Returns The cloned  Ellipsoid . equals(right : Ellipsoid) : Boolean Compares this Ellipsoid against the provided Ellipsoid componentwise. right  The other Ellipsoid. used. Returns true  if they are equal,  false  otherwise. toString() : String Creates a string representing this Ellipsoid in the format used  '[radii.x, radii.y, radii.z] . Returns A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'. cartographicToCartesian(cartographic : Number 3 , result : Number 3 ]) : Vector3 | Number 3 Converts the provided cartographic to Cartesian representation. cartographic  The cartographic position. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  Vector3  instance if none was provided. cartesianToCartographic(cartesian : Number 3 , result : Number 3 ]) : Vector3 | Number 3  |  undefined Converts the provided cartesian to cartographic representation. The cartesian is  undefined  at the center of the ellipsoid. cartesian  The Cartesian position to convert to cartographic representation. result  Optional object onto which to store the result. Returns The modified result parameter, new  Vector3  instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid. eastNorthUpToFixedFrame(origin : Number 3 , ellpsoid : Ellipsoid, result : Number 16 ) : Matrix4 | Number 16 Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes centered at the provided origin to the provided ellipsoid's fixed reference frame. The local axes are defined as: The  x  axis points in the local east direction. The  y  axis points in the local north direction. The  z  axis points in the direction of the ellipsoid surface normal which passes through the position. origin  The center point of the local reference frame. ellipsoid = Ellipsoid.WGS84  The ellipsoid whose fixed frame is used in the transformation. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  Matrix4  instance if none was provided. Notes Calls  localFrameToFixedFrame  with  east ,  north ,  up  axis. localFrameToFixedFrame(String firstAxis, secondAxis : String, thirdAxis : String | null, origin : Number 3   [ , result : Number 16 ]) : Matrix4 | Number 16 Computes a 4x4 transformation matrix from a reference frame centered at the provided origin to the ellipsoid's fixed reference frame. firstAxis  name of the first axis of the local reference frame. Must be 'east', 'north', 'up', 'west', 'south' or 'down'. secondAxis  name of the second axis of the local reference frame. thirdAxis  name of the third axis of the local reference frame. Can be omitted as it is implied by the cross product of the first two axis. origin  The center point of the local reference frame. result  Optional object onto which to store the result. Returns A 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters, in the modified  result  parameter or a new  Matrix4  instance if none was provided. geocentricSurfaceNormal(cartesian : Number 3 , result : Number 3 ]) : Vector3 | Number 3 Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position. cartesian  - The WSG84 cartesian coordinate for which to to determine the geocentric normal. result  - Optional object onto which to store the result. Returns The modified result parameter or a new  Vector3  instance if none was provided. geodeticSurfaceNormalCartographic(cartographic : Number 3 , result : Number 3 ]) : Vector3 | Number 3 Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. cartographic  The cartographic position for which to to determine the geodetic normal. result  Optional object onto which to store the result. Returns The modified result parameter or a new  Vector3  instance if none was provided. geodeticSurfaceNormal(cartesian : Number 3 , result : Number 3 ]) : Vector3 | Number 3 Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. cartesian  The Cartesian position for which to to determine the surface normal. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  Vector3  instance if none was provided. scaleToGeodeticSurface(cartesian : Number 3 , result : Number 3 ]) : Vector3 | Number 3  |  undefined Scales the provided Cartesian position along the geodetic surface normal so that it is on the surface of this ellipsoid. If the position is at the center of the ellipsoid, this function returns  undefined . cartesian  The Cartesian position to scale. result  Optional object onto which to store the result. Returns The modified result parameter, a new  Vector3  instance if none was provided, or undefined if the position is at the center. scaleToGeocentricSurface(cartesian : Number 3 , result : Number 3 ]) : Vector3 | Number 3 Scales the provided Cartesian position along the geocentric surface normal so that it is on the surface of this ellipsoid. cartesian  The Cartesian position to scale. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  Vector3  instance if none was provided. transformPositionToScaledSpace(position : Number 3 , result : Number 3 ]) : Vector3 | Number 3 Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying its components by the result of  Ellipsoid.oneOverRadii . position  The position to transform. result  Optional array into which to copy the result. Returns The position expressed in the scaled space. The returned instance is the one passed as the  result  parameter if it is not undefined, or a new instance of it is. transformPositionFromScaledSpace(position : Number 3 , result : Number 3 ]) : Vector3 | Number 3 Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying its components by the result of  Ellipsoid.radii . position  The position to transform. result  Optional array to which to copy the result. Returns The position expressed in the unscaled space. The returned array is the one passed as the  result  parameter, or a new  Vector3  instance. getSurfaceNormalIntersectionWithZAxis(position, buffer, result) : | undefined Computes a point which is the intersection of the surface normal with the z-axis. position  the position. must be on the surface of the ellipsoid. buffer = 0.0  A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid. result  Optional array into which to copy the result. Returns The intersection point if it's inside the ellipsoid,  undefined  otherwise. Throws position  is required. Ellipsoid  must be an ellipsoid of revolution ( radii.x == radii.y ). Ellipsoid.radii.z must be greater than 0. Notes: In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center. In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis). Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2 Attribution This class was ported from  Cesium  under the Apache 2 License.","headings":[{"value":"Ellipsoid","depth":1},{"value":"Usage","depth":2},{"value":"Static Fields","depth":2},{"value":"Ellipsoid.WGS84 : Ellipsoid (readonly)","depth":3},{"value":"Members","depth":2},{"value":"radii : Vector3 (readonly)","depth":3},{"value":"radiiSquared : Vector3 (readonly)","depth":3},{"value":"radiiToTheFourth : Vector3 (readonly)","depth":3},{"value":"oneOverRadii : Vector3 (readonly)","depth":3},{"value":"oneOverRadiiSquared : Vector3 (readonly)","depth":3},{"value":"minimumRadius : Number (readonly)","depth":3},{"value":"maximumRadius : Number","depth":3},{"value":"Methods","depth":2},{"value":"constructor(x : Number, y : Number, z : Number)","depth":3},{"value":"clone() : Ellipsoid","depth":3},{"value":"equals(right : Ellipsoid) : Boolean","depth":3},{"value":"toString() : String","depth":3},{"value":"cartographicToCartesian(cartographic : Number3, result : Number3]) : Vector3 | Number3","depth":3},{"value":"cartesianToCartographic(cartesian : Number3, result : Number3]) : Vector3 | Number3 | undefined","depth":3},{"value":"eastNorthUpToFixedFrame(origin : Number3, ellpsoid : Ellipsoid, result : Number16) : Matrix4 | Number16","depth":3},{"value":"localFrameToFixedFrame(String firstAxis, secondAxis : String, thirdAxis : String | null, origin : Number3 [, result : Number16]) : Matrix4 | Number16","depth":3},{"value":"geocentricSurfaceNormal(cartesian : Number3, result : Number3]) : Vector3 | Number3","depth":3},{"value":"geodeticSurfaceNormalCartographic(cartographic : Number3, result : Number3]) : Vector3 | Number3","depth":3},{"value":"geodeticSurfaceNormal(cartesian : Number3, result : Number3]) : Vector3 | Number3","depth":3},{"value":"scaleToGeodeticSurface(cartesian : Number3, result : Number3]) : Vector3 | Number3 | undefined","depth":3},{"value":"scaleToGeocentricSurface(cartesian : Number3, result : Number3]) : Vector3 | Number3","depth":3},{"value":"transformPositionToScaledSpace(position : Number3, result : Number3]) : Vector3 | Number3","depth":3},{"value":"transformPositionFromScaledSpace(position : Number3, result : Number3]) : Vector3 | Number3","depth":3},{"value":"getSurfaceNormalIntersectionWithZAxis(position, buffer, result) : | undefined","depth":3},{"value":"Attribution","depth":2}],"slug":"modules/geospatial/docs/api-reference/ellipsoid","title":"Ellipsoid"},{"excerpt":"Helpers Helper functions for geospatial. Usage Check if a given coordinate is close to the surface of the earth on the earth ellipsoid.","headings":[{"value":"Helpers","depth":1},{"value":"Usage","depth":2}],"slug":"modules/geospatial/docs/api-reference/helpers","title":"Helpers"},{"excerpt":"@math.gl/geoid math.gl  is a suite of math modules for 3D and geospatial applications. This module contains support for non-ellipsoidal surface using earth gravity models. For documentation please visit the  website .","headings":[{"value":"@math.gl/geoid","depth":1}],"slug":"modules/geoid","title":"@math.gl/geoid"},{"excerpt":"Overview The  @math.gl/geoid  module provides support for irregular Earth models defined by earth gravity model files. Background While spherical and ellipsoidal models of the earth can be very useful, the Earth is ultimately an irregular object, with lumps of higher density etc. This irregular model of the earth is usually referred to as a \"geoid\" (essentially, an irregular \"ellipsoid\"). Earth gravity models can be used to describe this geoid. The models implemented by  @math.gl/geoid  use a superposition of spherical harmonics to approximate measured gravity. Calculates difference between mean see level height and WGS84 ellipsoid height Earth Gravity Model Data Files Gravity Height Model data files tend to be stored in PGM format. Calculates difference between mean see level height and WGS84 ellipsoid height Input data have to be loaded from \"Earth Gravity Model\"  * .pgm file with \"PGMLoader\" A particular model file can be loaded on  https://geographiclib.sourceforge.io/html/geoid.html Attribution This implementation is a JavaScript port of selected code from [GeographicLib-1.50.1( https://geographiclib.sourceforge.io/html/index.html ), listed as Copyright Charles Karney  charles@karney.com , under the MIT license.","headings":[{"value":"Overview","depth":1},{"value":"Background","depth":2},{"value":"Earth Gravity Model Data Files","depth":2},{"value":"Attribution","depth":2}],"slug":"modules/geoid/docs","title":"Overview"},{"excerpt":"Geoid class  Geoid  - \"Gravity Height Model\" The  Geoid  class calculates difference between mean see level height and WGS84 ellipsoid height. It needs to be initialized with an earth gravity model file. Input data have to be loaded from \"Earth Gravity Model\"  * .pgm file with \"PGMLoader\". A particular model file can be loaded on  https://geographiclib.sourceforge.io/html/geoid.html Methods Constructor Create a  Geoid  instance. @param options - object which includes parameters parsed from  .pgm header\noptions.data - binary buffer of  .pgm file Calculates difference between mean see level height and WGS84 ellipsoid height @param lat - latitude\n@param lon - longitude\n@returns height in meters getHeight(lat: number, lon: number): number;","headings":[{"value":"Geoid","depth":1},{"value":"Methods","depth":2},{"value":"Constructor","depth":5},{"value":"getHeight(lat: number, lon: number): number;","depth":5}],"slug":"modules/geoid/docs/api-reference/geoid","title":"Geoid"},{"excerpt":"parsePGM Parse header of \"Earth Gravity Model\"  * .pgm file. Functions parsePGM(data, options) Parse \"Earth Gravity Model\" loaded from a  * .pgm file, e.g.  https://geographiclib.sourceforge.io/html/geoid.html @param {Uint8Array} data - binary buffer of pgm file\n@param {Object} options - loader options\n@returns {GeoidHeightModel} - instance of GeoidHeightModel class","headings":[{"value":"parsePGM","depth":1},{"value":"Functions","depth":2},{"value":"parsePGM(data, options)","depth":3}],"slug":"modules/geoid/docs/api-reference/parse-pgm","title":"parsePGM"},{"excerpt":"Overview math.gl  is a suite of math modules for 3D applications. This module contains classes for bounding boxes, view frustum intersections etc. For documentation please visit the  website .","headings":[{"value":"Overview","depth":1}],"slug":"modules/culling","title":"Overview"},{"excerpt":"WIP BoundingSphere.fromOrientedBoundingBox = function(orientedBoundingBox, result) {\nComputes a tight-fitting bounding sphere enclosing the provided oriented bounding box. @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided. Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided. Computes a bounding sphere from a rectangle projected in 2D. @param {Rectangle}  rectangle  The rectangle around which to create a bounding sphere.\n@param {Object}  projection=GeographicProjection  The projection used to project the rectangle into 2D. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided. Computes a bounding sphere from a rectangle projected in 2D. The bounding sphere accounts for the\nobject's minimum and maximum heights over the rectangle. @param {Rectangle}  rectangle  The rectangle around which to create a bounding sphere.\n@param {Object}  projection=GeographicProjection  The projection used to project the rectangle into 2D. minimumHeight =0.0 The minimum height over the rectangle. maximumHeight =0.0 The maximum height over the rectangle. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided. Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\non the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids. @param {Rectangle}  rectangle  The valid rectangle used to create a bounding sphere.\n@param {Ellipsoid}  ellipsoid=Ellipsoid.WGS84  The ellipsoid used to determine positions of the rectangle. surfaceHeight =0.0 The height above the surface of the ellipsoid. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided.","headings":[{"value":"WIP","depth":2}],"slug":"modules/culling/wip/bounding-sphere","title":"WIP"},{"excerpt":"AxisAlignedBoundingBox An  AxisAlignedBoundingBox  is a closed and convex cuboid that is aligned with the orthogonal axes. Usage AxisAlignedBoundingBox  can be created using two corners of the box: Or from a collection of points: Global Functions makeAxisAlignedBoundingBoxFromPoints(positions : Array 3 , result? : AxisAlignedBoundingBox) : AxisAlignedBoundingBox Computes an instance of an  AxisAlignedBoundingBox  of the given positions. positions  List of  Vector3  points that the bounding box will enclose. result  Optional object onto which to store the result. Fields center: Vector3 =  0, 0, 0 The center position of the box. halfDiagonal: Vector3 The positive diagonal vector. minimum: Vector3 The minimum corner of the bounding box. maximum: Vector3 The maximum corner of the bounding box. Methods constructor(minimum =  0, 0, 0 , maximum =  0, 0, 0 ) { constructor {Vector3}  minimum=Vector3.ZERO  The minimum corner of the box, i.e.  [xMin, yMin, zMin] . {Vector3}  maximum=Vector3.ZERO  The maximum corner of the box, i.e.  [xMax, yMax, zMax] . clone() : AxisAlignedBoundingBox Duplicates a  AxisAlignedBoundingBox  instance. Returns A new  AxisAlignedBoundingBox  instance. equals(right : AxisAlignedBoundingBox) : Boolean Compares the provided  AxisAlignedBoundingBox  componentwise and returns  true  if they are equal,  false  otherwise. right  The second  AxisAlignedBoundingBox Returns true  if left and right are equal,  false  otherwise. intersectPlane(plane : Plane) : INTERSECTION Determines which side of a plane the axis-aligned bounding box is located. plane  The plane to test against. Returns INTERSECTION.INSIDE  if the entire box is on the side of the plane the normal is pointing INTERSECTION.OUTSIDE  if the entire box is on the opposite side, and INTERSECTION.INTERSECTING  if the box intersects the plane. distanceTo(point : Number 3 ) : Number Computes the estimated distance from the closest point on a bounding box to a point. point  The point Returns The estimated distance from the bounding sphere to the point. distanceSquaredTo(point : Number 3 ) : Number Computes the estimated distance squared from the closest point on a bounding box to a point. point  The point Returns The estimated distance squared from the bounding sphere to the point.","headings":[{"value":"AxisAlignedBoundingBox","depth":1},{"value":"Usage","depth":1},{"value":"Global Functions","depth":2},{"value":"makeAxisAlignedBoundingBoxFromPoints(positions : Array3, result? : AxisAlignedBoundingBox) : AxisAlignedBoundingBox","depth":3},{"value":"Fields","depth":2},{"value":"center: Vector3 = 0, 0, 0","depth":3},{"value":"halfDiagonal: Vector3","depth":3},{"value":"minimum: Vector3","depth":3},{"value":"maximum: Vector3","depth":3},{"value":"Methods","depth":2},{"value":"constructor(minimum = 0, 0, 0, maximum = 0, 0, 0) {","depth":3},{"value":"constructor","depth":3},{"value":"clone() : AxisAlignedBoundingBox","depth":3},{"value":"equals(right : AxisAlignedBoundingBox) : Boolean","depth":3},{"value":"intersectPlane(plane : Plane) : INTERSECTION","depth":3},{"value":"distanceTo(point : Number3) : Number","depth":3},{"value":"distanceSquaredTo(point : Number3) : Number","depth":3}],"slug":"modules/culling/docs/api-reference/axis-aligned-bounding-box","title":"AxisAlignedBoundingBox"},{"excerpt":"Overview The  @math.gl/culling  module provides primitives for implementing frustum culling: Bounding boxes and intersection logic Fully \"transformable\" primitives (i.e. oriented bounding boxes as opposed to just axis-aligned bounding boxes). The culling module does not attempt to be a general \"physics-based\" collision detection library (e.g. it does not handle time-interpolated intersections like a physics library would). Classes Class Description CullingVolume BoundingSphere OrientedBoundingBox Plane Example Usage Create bounding volumes for your objects/geometries, and create  BoundingSphere  or  OrientedBoundingBox  instances. Extract your camera view frustum parameters and create a  PerspectiveFrustum  instance. You can now test your bounding volumes to see if the intersect the view frustum. Framework Independence Like all non-core math.gl modules, this library can be used without the math.gl core classes. Any input vectors can be supplied as length 3 JavaScript  Array  instances. Any result vectors can be treated as length 3 JavaScript  Array  instances (they may be math.gl  Vector3 ). The core math.gl classes inherit from JavaScript  Array  and can be used directly as input. History This library was initially developed as a fork of the Cesium math library as part of a collaboration between Cesium and Uber to provide framework-independent, portable support for the 3D tiles specification. Attribution This code in was initially forked from  Cesium  under the Apache 2 License.","headings":[{"value":"Overview","depth":1},{"value":"Classes","depth":2},{"value":"Example Usage","depth":2},{"value":"Framework Independence","depth":2},{"value":"History","depth":2},{"value":"Attribution","depth":2}],"slug":"modules/culling/docs","title":"Overview"},{"excerpt":"CullingVolume A culling volume defined by planes. Static Members CullingVolume.MASK_OUTSIDE For plane masks (as used in  CullingVolume#computeVisibilityWithPlaneMask ), this special value represents the case where the object bounding volume is entirely outside the culling volume. CullingVolume.MASK_INSIDE For plane masks (as used in  CullingVolume.computeVisibilityWithPlaneMask ), this value represents the case where the object bounding volume is entirely inside the culling volume. CullingVolume.MASK_INDETERMINATE For plane masks (as used in CullingVolume.computeVisibilityWithPlaneMask ), this value represents the case where the object bounding volume (may) intersect all planes of the culling volume. Methods constructor([planes : Plane[]]) planes = []  An array of clipping planes. Each plane is represented by a Cartesian4 object, where the x, y, and z components define the unit vector normal to the plane, and the w component is the distance of the plane from the origin. fromBoundingSphere(boundingSphere : BoundingSphere) Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere. The planes are aligned to the x, y, and z axes in world coordinates. boundingSphere  The bounding sphere used to create the culling volume. computeVisibility(boundingVolume : Object) : Interset Determines whether a bounding volume intersects the culling volume. boundingVolume  The bounding volume whose intersection with the culling volume is to be tested. Returns INTERSECTION.OUTSIDE ,  INTERSECTION.INTERSECTING , or  INTERSECTION.INSIDE . computeVisibilityWithPlaneMask(boundingVolume : Object, parentPlaneMask : Number) : Number Determines whether a bounding volume intersects the culling volume. boundingVolume  The bounding volume whose intersection with the culling volume is to be tested. parentPlaneMask  A bit mask from the boundingVolume's parent's check against the same culling volume, such that if  planeMask & (1 << planeIndex) === 0 , for  k < 31 , then the parent (and therefore this) volume is completely inside  plane[planeIndex]  and that plane check can be skipped. Returns A plane mask as described above (which can be applied to this boundingVolume's children). Attribution This class was ported from  Cesium  under the Apache 2 License.","headings":[{"value":"CullingVolume","depth":1},{"value":"Static Members","depth":2},{"value":"CullingVolume.MASK_OUTSIDE","depth":3},{"value":"CullingVolume.MASK_INSIDE","depth":3},{"value":"CullingVolume.MASK_INDETERMINATE","depth":3},{"value":"Methods","depth":2},{"value":"constructor([planes : Plane[]])","depth":3},{"value":"fromBoundingSphere(boundingSphere : BoundingSphere)","depth":3},{"value":"computeVisibility(boundingVolume : Object) : Interset","depth":3},{"value":"computeVisibilityWithPlaneMask(boundingVolume : Object, parentPlaneMask : Number) : Number","depth":3},{"value":"Attribution","depth":2}],"slug":"modules/culling/docs/api-reference/culling-volume","title":"CullingVolume"},{"excerpt":"BoundingSphere A  bounding sphere  with a center and a radius. Usage Create a bounding sphere around the unit cube Sort bounding spheres from back to front Global Functions makeBoundingSphereFromPoints(positions : iterator, result? : BoundingSphere) : BoundingSphere Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points. The bounding sphere is computed by running two algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit. positions  An iterable (e.g. array) of points that the bounding sphere will enclose. Each point must have  x ,  y , and  z  properties. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if one was not provided. See  Bounding Sphere computation article Fields center : Vector3 The center point of the sphere. radius : Number The radius of the sphere. Members constructor(center : Number 3 , radius : Number) Creates a new  BoundingSphere center = [0, 0, 0]  The center of the bounding sphere. radius = 0.0  The radius of the bounding sphere. fromCenterRadius(center : Number 3 , radius : Number) : BoundingSphere Sets the  BoundingSphere  from center and radius center = [0, 0, 0]  The center of the bounding sphere. radius = 0.0  The radius of the bounding sphere. fromCornerPoints(corner : Number 3 , oppositeCorner : Number 3 , result? : BoundingSphere) : BoundingSphere Computes a bounding sphere from the two corner points of an axis-aligned bounding box. The sphere tighly and fully encompases the box. corner  The minimum height over the rectangle. oppositeCorner  The maximum height over the rectangle. fromBoundingSpheres(boundingSpheres : BoundingSphere[]) : BoundingSphere Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres. boundingSpheres  The array of bounding spheres. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided. clone() Duplicates a  BoundingSphere  instance. Returns A new  BoundingSphere  instance equals(right : BoundingSphere) Boolean Compares the provided  BoundingSphere  componentwise and returns  true  if they are equal,  false  otherwise. right  The second  BoundingSphere . Returns true  if left and right are equal,  false  otherwise. union(right : BoundingSphere) : BoundingSphere Computes a bounding sphere that contains both the this and the  right  bounding spheres. right  The second  BoundingSphere . expand(point : Number 3 ) : BoundingSphere Computes a bounding sphere by enlarging the provided sphere to contain the provided point. point  A point to enclose in a bounding sphere. intersectPlane(plane : Plane) : INTERSECTION Determines which side of a plane a sphere is located. plane  The plane to test against.\nReturns INTERSECTION.INSIDE  if the entire sphere is on the side of the plane the normal is pointing INTERSECTION.OUTSIDE  if the entire sphere is on the opposite side INTERSECTION.INTERSECTING  if the sphere intersects the plane. transform(transform : Number 16 ) : BoundingSphere Applies a 4x4 affine transformation matrix to a bounding sphere. transform  The transformation matrix to apply to the bounding sphere. distanceSquaredTo(point) : Number Computes the estimated distance squared from the closest point on a bounding sphere to a point. point  The point Returns The estimated distance squared from the bounding sphere to the point. transformWithoutScale(sphere, transform, result) Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\nThe transformation matrix is not verified to have a uniform scale of 1.\nThis method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}. @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n@param {Matrix4} transform The transformation matrix to apply to the bounding sphere. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided. @example\nvar modelMatrix = Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\nvar boundingSphere = new BoundingSphere();\nvar newBoundingSphere = BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix); computePlaneDistances (sphere, position, direction, result) The distances calculated by the vector from the center of the bounding sphere to position projected onto direction plus/minus the radius of the bounding sphere. If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the closest and farthest planes from position that intersect the bounding sphere. @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n@param {Cartesian3} position The position to calculate the distance from.\n@param {Cartesian3} direction The direction from position.\n@param {Interval}  result  A Interval to store the nearest and farthest distances.\n@returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction. projectTo2D(sphere, projection, result) Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates. @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n@param {Object}  projection=GeographicProjection  The projection to 2D. result  Optional object onto which to store the result. Returns The modified  result  parameter or a new  BoundingSphere  instance if none was provided. Attribution This class was ported from  Cesium  under the Apache 2 License.","headings":[{"value":"BoundingSphere","depth":1},{"value":"Usage","depth":2},{"value":"Global Functions","depth":2},{"value":"makeBoundingSphereFromPoints(positions : iterator, result? : BoundingSphere) : BoundingSphere","depth":3},{"value":"Fields","depth":2},{"value":"center : Vector3","depth":3},{"value":"radius : Number","depth":3},{"value":"Members","depth":2},{"value":"constructor(center : Number3, radius : Number)","depth":3},{"value":"fromCenterRadius(center : Number3, radius : Number) : BoundingSphere","depth":3},{"value":"fromCornerPoints(corner : Number3, oppositeCorner : Number3, result? : BoundingSphere) : BoundingSphere","depth":3},{"value":"fromBoundingSpheres(boundingSpheres : BoundingSphere[]) : BoundingSphere","depth":3},{"value":"clone()","depth":3},{"value":"equals(right : BoundingSphere) Boolean","depth":3},{"value":"union(right : BoundingSphere) : BoundingSphere","depth":3},{"value":"expand(point : Number3) : BoundingSphere","depth":3},{"value":"intersectPlane(plane : Plane) : INTERSECTION","depth":3},{"value":"transform(transform : Number16) : BoundingSphere","depth":3},{"value":"distanceSquaredTo(point) : Number","depth":3},{"value":"transformWithoutScale(sphere, transform, result)","depth":3},{"value":"computePlaneDistances (sphere, position, direction, result)","depth":3},{"value":"projectTo2D(sphere, projection, result)","depth":3},{"value":"Attribution","depth":2}],"slug":"modules/culling/docs/api-reference/bounding-sphere","title":"BoundingSphere"},{"excerpt":"Plane A plane in Hessian Normal Form defined by  ax + by + cz + d = 0  where  [a, b, c]  is the plane's  normal ,  d  is the signed distance to the plane (from the origin along the normal), and  [x, y, z]  is any point on the plane. Usage Create the plane  x=0 Create a tangent plane for a cartographic coordinate Fields normal : Vector3 The plane's normal. distance : Number The shortest distance from the origin to the plane. The sign of  distance  determines which side of the plane the origin is on. If  distance  is positive, the origin is in the half-space in the direction of the normal; if negative, the origin is in the half-space opposite to the normal; if zero, the plane passes through the origin. Methods constructor(normal : Number 3 , distance : Number) Vector3  normal The plane's normal (normalized). Number distance The shortest distance from the origin to the plane. The sign of  distance  determines which side of the plane the origin is on. If  distance  is positive, the origin is in the half-space in the direction of the normal; if negative, the origin is in the half-space opposite to the normal; if zero, the plane passes through the origin. Throws Normal must be normalized fromPointNormal(point : Number 3 , normal : Number 3 ) : Plane Creates a plane from a normal and a point on the plane. Vector3  point The point on the plane. Vector3  normal The plane's normal (normalized). Plane  result  The object onto which to store the result. Throws Normal must be normalized Plane.fromCoefficients(coefficients : Number 4 ) : Plane Creates a plane from the general equation coefficients  The plane coefficients (normalized). Throws Normal must be normalized clone() : Plane Duplicates a Plane instance. Returns A new Plane instance with the same values equals(right : Plane) : Boolean Compares the provided Planes by normal and distance and returns  true  if they are equal,  false  otherwise. right  The second plane. Returns true  if left and right are equal,  false  otherwise. getPointDistance(point : Number 3 ) : Number Computes the signed shortest distance of a point to a plane. The sign of the distance determines which side of the plane the point is on. If the distance is positive, the point is in the half-space in the direction of the normal; if negative, the point is in the half-space opposite to the normal; if zero, the plane passes through the point. point  The point. Returns Number The signed shortest distance of the point to the plane. projectPointOntoPlane(point : Number 3 , result : Number 3 ]) : Number 3 Projects a point onto the plane. point  The point to project onto the plane result  The result point. If undefined, a new  Array  will be created. Returns The modified result parameter or a new  Vector3  instance if one was not provided. transform(transform : Number 16 ) : Plane Transforms the plane by the given transformation matrix. Matrix4 transform The transformation matrix. Plane  result  The object into which to store the result. Returns Plane The plane transformed by the given transformation matrix. Attribution This class was ported from  Cesium  under the Apache 2 License.","headings":[{"value":"Plane","depth":1},{"value":"Usage","depth":2},{"value":"Fields","depth":2},{"value":"normal : Vector3","depth":3},{"value":"distance : Number","depth":3},{"value":"Methods","depth":2},{"value":"constructor(normal : Number3, distance : Number)","depth":3},{"value":"fromPointNormal(point : Number3, normal : Number3) : Plane","depth":3},{"value":"Plane.fromCoefficients(coefficients : Number4) : Plane","depth":3},{"value":"clone() : Plane","depth":3},{"value":"equals(right : Plane) : Boolean","depth":3},{"value":"getPointDistance(point : Number3) : Number","depth":3},{"value":"projectPointOntoPlane(point : Number3, result : Number3]) : Number3","depth":3},{"value":"transform(transform : Number16) : Plane","depth":3},{"value":"Attribution","depth":2}],"slug":"modules/culling/docs/api-reference/plane","title":"Plane"},{"excerpt":"@math.gl/core math.gl  is a suite of math modules for 3D applications. This module contains classes for vectors and matrices etc. For documentation please visit the  website .","headings":[{"value":"@math.gl/core","depth":1}],"slug":"modules/core","title":"@math.gl/core"},{"excerpt":"Overview Basic 3D math classes (vectors, matrices, quaternions etc) for JavaScript. Installation Classes Class Description Vector2 Two element vector, inherits from  Array Vector3 Three element vector, inherits from  Array Vector4 Four element vector, inherits from  Array Matrix3 3x3 matrix, inherits from  Array Matrix4 4x4 matrix, inherits from  Array Quaternion Quaternion in  [x,y,z,w]  form, inherits from  Array Euler 3 Euler angles and rotation order SphericalCoordinates 2 rotations and a radius Usage Design Goals Some of the design goals for the math.gl core library Performance  - The core math.gl classes are built on top of  gl-matrix .  gl-matrix  has a reputation for being the most performant and battle-tested JavaScript math library around. Array-Based  - math.gl classes (like  Vector3 ,  Matrix4 ) are subclasses of the built-in JavaScript  Array  which enables applications to use them interchangeably with plain (or typed) arrays. Debug Friendly  - math.gl offers  optional  error checking after every math operation which makes quick work of locating coding errors and bad input data. Printing support for objects ( toString ) also simplifies debugging. Size Conscious  - math.gl is published as multiple modules to let applications cherry-pick required functionality, and is optimizes dependencies for tree-shaking to make sure you only pay for (bundle) what you use.","headings":[{"value":"Overview","depth":1},{"value":"Installation","depth":2},{"value":"Classes","depth":2},{"value":"Usage","depth":2},{"value":"Design Goals","depth":2}],"slug":"modules/core/docs","title":"Overview"},{"excerpt":"About the Vector Classes (WIP) This document is Work-In-Progress. Two, three and four dimensional vector classes Vector2, Vector3, Vector4 Methods Method Description constructor Creates a Vector ELEMENTS Get the dimensionality of the vector x Set/get x component y Set/get y component z Set/get z component ( Vector3  and  Vector4  only) w Set/get w component ( Vector4  only) set Set values add Vectors addition subtract Vectors subtraction multiply Vectors multiplication divide Vectors division scale Scales a Vector by a scalar number scaleAndAdd Adds two vectors after scaling the second operand by a scalar value negate Negate a vector inverse Inverse a vector ( Vector3  and  Vector4  only normalize Normalize a vector dot Dot product of two vectors cross Cross product of two vectors ( Vector3  only) lerp Linear interpolation between two Vector operation Apply general operations on all vectors","headings":[{"value":"About the Vector Classes (WIP)","depth":1},{"value":"Vector2, Vector3, Vector4 Methods","depth":2}],"slug":"modules/core/docs/wip/using-vectors","title":"About the Vector Classes (WIP)"},{"excerpt":"Features (WIP) This document is Work-In-Progress. See  features  for more details. Array-based This allows you to keep your API functions general (the accept general arrays and so are not tied to a specific math library). Debugging Optional error checking after every math operation makes quick work of locating coding errors and bad data. Printing support simplifies debugging Only minor performance impact, and can be disabled when performance is critical. WebGL-friendly Column Major atrices: while all accessors,  toString()  etc are row-major.\nmatrices are organized internally in the layout expected\nby WebGL (an array of contiguous floats in column-major order), toArray  and  fromArray  functions take optional offsets allowing\ncopying directly to and from vertex attribute array. GLSL math functions (radians, sin etc) made available in JavaScript\nand work both on scalars and vectors / math objects. Documentation Most JavaScript 3D math libraries come with a reference documentation only. It can be a Size Conscious A math library can quickly get big as a various , gl-matrix is a good example, there are a number of modules on npm that contain subsets of gl-matrix to work around its size. Focus on functions that are likely to be most important in WebGL applications. Supported Browsers Some background: math.gl classes are subclasses of the built-in JavaScript  Array .  Array  subclassing is an ES6/JS2015 feature. This feature (even after being transpiled to ES5) does not work with older browsers. For details of the technical complication, see ( babel-plugin-transform-builtin-extend ). Overview math.gl is a JavaScript math library primarily intended to support WebGL applications. It is a generic library but was developed as a companion for  luma.gl  and  deck.gl . math.gl contains a set of classes (Matrix4 etc) to complement the procedural interface of gl-matrix. It also imports a limited subset of the standard  gl-matrix  functions (to keep bundle size down), these can be used in parallel with the classes. Who is this for? JavaScript WebGL programmers who: Need a great JavaScript math library for basic computional geometry purposes. like the functionality offered by the gl-matrix library need tree-shaking support want to use object orientated math programming style (ability to chain operations). want optional extra error checking do not need to support old (pre-IE10) browsers. Features Array-based All math objects can be used directly with any Javascript function that expects array arguments. No need to call  toArray  or similar. Error checking  to assist in debugging. Can be disabled when performance is critical. WebGL-friendly Matrices: while all accessors,  toString()  etc are row-major. Matrices are organized internally in the layout expected by WebGL (an array of contiguous floats in column-major order), toArray  and  fromArray  functions take optional offsets allowing copying directly to and from vertex attribute arrays. GLSL math functions (radians, sin etc) made available in JavaScript and work both on scalars and vectors / math objects. Design Notes Math objects are  Arrays  - All math objects are subclasses of the built-in JavaScript  Array  class, which means that class instances can be used wherever an array is expected. I.e. these classes are not wrappers of  Array s, they  are   Array s, just with additional methods. Focuses on needs of WebGL based applications and basic computational geometry, which includes 4x4 matrices, 2, 3 and 4 dimensional vectors and quaternions. May grow to include other classes, but is not intended to become a general math library. History Started out as a set of object oriented wrappers for the procedural  gl-matrix  library. Roadmap Additional classes and functions. This library might grow beyond just providing  gl-matrix  wrappers if additional classes are deemed valuable for the target user group. API differences with gl-matrix The class API is intentionally designed to remain intuitively similar to the wrapped  gl-matrix  procedures, usually just removing the first one or two parameters from each function (the out argument and the first input arguments, both are implictly set to this), and exposes the remaining arguments in the same order as the gl-matrix api. Only in a few cases where  gl-matrix  methods take a long list arguments (e.g.  mat4.perspective ,  mat4.ortho  etc) or return multiple values (e.g.  quat.getAxisRotation ) do methods provide a modified API that is more natural for modern ES6 applications to use, e.g. using named parameters, or collecting all results in one returned object. Also, for transforming vectors with matrices, the  transform*  methods are offered in the matrix classes, instead of on the vector classes. They also (optionally) auto allocate the result vectors. Caveats A technical caveat is that JavaScript  Array  subclassing, which is fundamental to the design of this library, is only supported on \"evergreen\" browsers, such as Chrome, Safari, Firefox, Edge etc, i.e. no Internet Explorer < 10 ( details ). If this is not acceptable, math.gl is not the right choice for you. As a fallback, you can always use  gl-matrix  directly.","headings":[{"value":"Features (WIP)","depth":1},{"value":"Array-based","depth":2},{"value":"Supported Browsers","depth":2},{"value":"Overview","depth":2},{"value":"Who is this for?","depth":2},{"value":"Features","depth":2},{"value":"Design Notes","depth":1},{"value":"History","depth":1},{"value":"Roadmap","depth":1},{"value":"API differences with gl-matrix","depth":2},{"value":"Caveats","depth":2}],"slug":"modules/core/docs/wip/features","title":"Features (WIP)"},{"excerpt":"OrientedBoundingBox An  OrientedBoundingBox  is a closed and convex cuboid. It can provide a tighter bounding volume than a bounding sphere or an axis aligned bounding box in many cases. The class support two representations of an oriented bounding box: A half-axes based representation. 3 half axes vectors ( halfAxes: Matrix3 ) describe size and orientation of a bounding box. This approach is used in the 3DTiles specification ( https://github.com/CesiumGS/3d-tiles/tree/master/specification#box ) A half-size-quaternion based representation. A  halfSize: number[3]  array describes size, a  quaternion: Quaternion  describes orientation of a bounding box. This approach is used in the Indexed 3d Scene Layer (I3S) specification ( https://github.com/Esri/i3s-spec/blob/master/docs/1.7/obb.cmn.md ). Usage Create an  OrientedBoundingBox  using a transformation matrix, a position where the box will be translated, and a scale. Sort bounding boxes from back to front Compute an oriented bounding box enclosing two points. Global Functions makeOrientedBoundingBoxFromPoints(positions : Array 3 , result? : OrientedBoundingBox) : OrientedBoundingBox Computes an instance of an  OrientedBoundingBox  of the given positions.\nThis is an implementation of Stefan Gottschalk's  Collision Queries using Oriented Bounding Boxes  (PHD thesis). positions  List of  Vector3  points that the bounding box will enclose. result  Optional object onto which to store the result. Fields center: Vector3 The center position of the box. halfAxes: Matrix3 The transformation matrix, to rotate the box to the right position. readonly halfSize: number[] The array with three half-sizes for the bounding box readonly quaternion: Quaternion The quaternion describing the orientation of the bounding box Methods constructor(center =  0, 0, 0 , halfAxes =  0, 0, 0, 0, 0, 0, 0, 0, 0 ) { constructor center = Vector3.ZERO  The center of the box. halfAxes = Matrix3.ZERO  The three orthogonal half-axes of the bounding box. Equivalently, the transformation matrix, to rotate and scale a cube centered at the origin. fromCenterHalfSizeQuaternion(center : number[], halfSize : number[], quaternion : number[]) : OrientedBoundingBox Create an OrientedBoundingBox from a half-size-quaternion based OBB clone() : OrientedBoundingBox Duplicates a OrientedBoundingBox instance. Returns A new  OrientedBoundingBox  instance. equals(right: OrientedBoundingBox) : Boolean Compares the provided OrientedBoundingBox componentwise and returns  true  if they are equal,  false  otherwise. right  The second  OrientedBoundingBox Returns true  if left and right are equal,  false  otherwise. intersectPlane(plane : Plane) : INTERSECTION Determines which side of a plane the oriented bounding box is located. plane  The plane to test against. Returns INTERSECTION.INSIDE  if the entire box is on the side of the plane the normal is pointing INTERSECTION.OUTSIDE  if the entire box is on the opposite side, and INTERSECTION.INTERSECTING  if the box intersects the plane. distanceTo(point : Number 3 ) : Number Computes the estimated distance from the closest point on a bounding box to a point. point  The point Returns The estimated distance from the bounding sphere to the point. distanceSquaredTo(point : Number 3 ) : Number Computes the estimated distance squared from the closest point on a bounding box to a point. point  The point Returns The estimated distance squared from the bounding sphere to the point. computePlaneDistances(position : Number 3 , direction : Number 3 , result : Number 2 ]) : Number 2 The distances calculated by the vector from the center of the bounding box to position projected onto direction. If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the closest and farthest planes from position that intersect the bounding box. position  The position to calculate the distance from. direction  The direction from position. result  An optional Interval to store the nearest and farthest distances. Returns The nearest and farthest distances on the bounding box from position in direction. Attribution This class was ported from  Cesium  under the Apache 2 License.","headings":[{"value":"OrientedBoundingBox","depth":1},{"value":"Usage","depth":1},{"value":"Global Functions","depth":2},{"value":"makeOrientedBoundingBoxFromPoints(positions : Array3, result? : OrientedBoundingBox) : OrientedBoundingBox","depth":3},{"value":"Fields","depth":2},{"value":"center: Vector3","depth":3},{"value":"halfAxes: Matrix3","depth":3},{"value":"readonly halfSize: number[]","depth":3},{"value":"readonly quaternion: Quaternion","depth":3},{"value":"Methods","depth":2},{"value":"constructor(center = 0, 0, 0, halfAxes = 0, 0, 0, 0, 0, 0, 0, 0, 0) {","depth":3},{"value":"constructor","depth":3},{"value":"fromCenterHalfSizeQuaternion(center : number[], halfSize : number[], quaternion : number[]) : OrientedBoundingBox","depth":3},{"value":"clone() : OrientedBoundingBox","depth":3},{"value":"equals(right: OrientedBoundingBox) : Boolean","depth":3},{"value":"intersectPlane(plane : Plane) : INTERSECTION","depth":3},{"value":"distanceTo(point : Number3) : Number","depth":3},{"value":"distanceSquaredTo(point : Number3) : Number","depth":3},{"value":"computePlaneDistances(position : Number3, direction : Number3, result : Number2]) : Number2","depth":3},{"value":"Attribution","depth":2}],"slug":"modules/culling/docs/api-reference/oriented-bounding-box","title":"OrientedBoundingBox"},{"excerpt":"Debugging This article is a work in progress. About Validation and Debug Support TBA: Turning on an off performance implications About \"Printing\" Generating a string representation of a math.gl object with desired precision and formatting. Every math.gl object has a  formatString({...opts})  method that allows you to stringify an object with special options set. Each object also defines the built-in JavaScript function  toString()  to call  formatString()  with the global printing options in the math.gl  config  object. toString  and  formatString  methods print with controllable precision Print Parameter Default Description printPrecision 4 Number of significant digits printTypes false Prints the name of the math.gl type (e.g.  Vector3[...]  instead of  [...] printDegrees false Prints degrees instead of radians (e.g. for  Euler  and  SphericalCoordinates ) printRowMajor true Prints matrices as row major which makes them look more familiar instead of as column major (which is how they are stored internally for WebGL compatibility).","headings":[{"value":"Debugging","depth":1},{"value":"About Validation and Debug Support","depth":2},{"value":"About \"Printing\"","depth":2}],"slug":"modules/core/docs/developer-guide/debugging","title":"Debugging"},{"excerpt":"Using with Other Frameworks This article is a work in progress. math.gl is designed to be (reasonably) interoperable with other major math frameworks. Using with gl-matrix API comparison The math.gl API is intentionally designed to remain intuitively similar to the wrapped  gl-matrix  procedures, usually just removing the first one or two parameters from each function (the out argument and the first input arguments, both are implictly set to  this ), and exposes the remaining arguments in the same order as the gl-matrix api. Only in a few cases where  gl-matrix  methods take a long list arguments (e.g.  Matrix4.perspective ,  Matrix4.ortho  etc) or return multiple values (e.g.  quat.getAxisRotation ) do methods provide a modified API that is more natural for modern ES6 applications to use, e.g. using named parameters, or collecting all results in one returned object. Also, for transforming vectors with matrices, the  transform*  methods are offered in the matrix classes, instead of on the vector classes. They also (optionally) auto allocate the result vectors. In code that is very frequently executed, working with directly with gl-matrix can sometimes provide better performance math.gl. References Top learn more about gl-matrix. The  gl-matrix docs  are a good start. Additionally, the gl-matrix source code is partially updated with JSDoc. Using with THREE.js math.gl makes efforts to be compatible with the THREE.js math API. Method Interoperability In particular, the basic math.gl math classes have implementations of most of the methods that THREE.js defines. math.gl THREE.js Notable differences Vector2 THREE.Vector2 length()  =>  len() Vector3 THREE.Vector3 ditto Vector4 THREE.Vector4 ditto Matrix3 THREE.Matrix3 Math.gl stores in column-major order by default Matrix4 THREE.Matrix4 ditto Can a THREE.Math class be created/initialized from a math.gl class? Probably yes, as we expose x, y, z accessors Can a math.gl class be created/initialized from a THREE.Math class? Probably not yet, as we don't look for x, y, z. Notable Incompatibilities Colum-Major vs. Row-Major Matrices By default, math.gl stores matrices in column-major order internally (while exposing a row-major friendly interface), whereas THREE.js stores matrices in row-major order. Array.length() Since math.gl's classes are subclasses of JavaScripts built-in  Array  class, the  length  property has the special meaning defined by  Array , so it is not possible to implement the  Vector.length()  method defined by THREE.js. Instead a  Vector.len()  method is offered on math.gl  Vector  classes. Cross-Library Convenience Methods A complication with THREE.js is that the framework is not strict about separating the library into independent layers. Thus the THREE math classes have convenience methods that accept other THREE.js objects such  Geometries  and  BufferAttributes . These methods are not implemented in math.gl. Remarks An indicator of the level of THREE.js compatibility is the fact that math.gl includes a copy of the math test suites from THREE.js, parts of which pass cleanly when run the math.gl classes listed above (admittedly with a few disabled cases). While it would of course be nice to be able to state \"100% compatiblity\" with the THREE.js math API, there are hard technical constraints. For instance, since math.gl's classes are subclasses of JavaScripts built-in  Array  class, the  length  property has the special meaning defined by  Array , so it is not possible to implement the  Vector.length()  method defined by THREE.js. Note that THREE.js compatibility methods will not always be implemented in the most performant way. Every compatibility methods adds size to the library and if they can be implemented in a compact way by calling existing methods that is often preferred over raw speed.","headings":[{"value":"Using with Other Frameworks","depth":1},{"value":"Using with gl-matrix","depth":2},{"value":"API comparison","depth":3},{"value":"References","depth":2},{"value":"Using with THREE.js","depth":2},{"value":"Method Interoperability","depth":3},{"value":"Notable Incompatibilities","depth":3},{"value":"Colum-Major vs. Row-Major Matrices","depth":3},{"value":"Array.length()","depth":3},{"value":"Cross-Library Convenience Methods","depth":3},{"value":"Remarks","depth":3}],"slug":"modules/core/docs/developer-guide/external-frameworks","title":"Using with Other Frameworks"},{"excerpt":"Performance The code vector and matrix operations in math.gl are based on gl-matrix which is designed as a high performance JavaScript 3D math library. Since math.gl uses gl-matrix functions under the hood, math.gl's performance is usually very close to gl-matrix, but the additional conveniences in math.gl do come with a certain overhead. Understanding this overhead can help you write more performant code and work around performance issues. In cases where javascript math calculations are performance critical, you can always use gl-matrix operations directly. See (./docs/get-started/using-with-gl-matrix.md). Essentially, since all math.gl classes inherit from  Array s they work directly as arguments to gl-matrix functions, no copying necessary. Disabling Debug Checks If debug mode has been turned on, math.gl checks that objects after every operation. Enabling the checks has a modest impact on performance. Verifying that error checks are not turned on. Minimizing Object Creation The biggest performance issue in math.gl (and essentially all other JavaScript math libraries) is object creation cost. Creating new  Vector3  and  Matrix4  instances every time a calculation is made incurs significant overhead. There are two standard techniques to avoid object creation costs. Resuing Objects Therefore, reusing objects where possible is an important technique to optimize performance. A typical technique is to allocate a global object in the file. Replace with Note that while creating objects can be slow, copying data into a temo object (e.g.  vector4.copy([1, 1, 1, 1])  or  vector4.copy([1, 1, 1, 1]) ) is very fast. Supplying  result  Objects A number of methods, such as  Matrix4.transformVector() , allocate new objects as return values. These methods typically accept an optional  result  argument which can be populated and returned. By providing a  result  value, you revent the allocation of a new object and instead reuse an object you have already allocated. vs. Browser, OS version etc The JavaScript engine powering Chrome and Node is still improving. The performance difference between e.g. Node 8 and Node 11 is rather staggering. Benchmarking The math.gl repository comes with a benchmark suite that you can run to see what operations are fast and which take more time in your environment. You can run the benchmarks both in Node.js and in the browser JavaScript Engine Optimizations This section should be considered advanced, and is not required reading for the normal math.gl user. However if you are writing your own math code it can be useful to have an understanding. To get good performance it is important to structure code so that it can be compiled and optimized by the JavaScript engine in use. math.gl focuses on optimizing for the V8 engine, since it is used both by Chrome and Node.js, however the optimizations are general and should also be relevant to other optimizing JavaScript engines. In particular, math.gl makes efforts to ensure that the engine knows that fields in math classes contain numbers, which allows for important optimizations that can result in a  ~ 5x performance difference for simple operations. A good introduction to the topic can be found in  JavaScript Performance Pitfalls in V8 .","headings":[{"value":"Performance","depth":1},{"value":"Disabling Debug Checks","depth":2},{"value":"Minimizing Object Creation","depth":2},{"value":"Resuing Objects","depth":3},{"value":"Supplying result Objects","depth":3},{"value":"Browser, OS version etc","depth":2},{"value":"Benchmarking","depth":2},{"value":"JavaScript Engine Optimizations","depth":2}],"slug":"modules/core/docs/developer-guide/performance","title":"Performance"},{"excerpt":"Floating Point This article is a work in progress. Precision About Comparisons Due to small rounding errors, exact equality is often not a reliable way to compare floating point numbers. Therefore the default  equals  operation checks that two numbers are within a small delta. There is also an  exactEquals  method that compares the floating point values directly. Floating point comparison implementation in gl-matrix and alternatives (links) Comparisons","headings":[{"value":"Floating Point","depth":1},{"value":"Precision","depth":2},{"value":"About Comparisons","depth":3}],"slug":"modules/core/docs/developer-guide/floating-point","title":"Floating Point"},{"excerpt":"Transformations math.gl allows you to create mathematical objects and then apply transformations on those objects. Objects are typically vectors but can also be more complex object such as spheres, planes, boxes etc, and transformations are typically represented by matrices and quaternions. Representing Transformations Transformations can be represented in many different notations but for computational purposes it is efficient to express them as matrices, or in some cases as quaternions. The most general transform is a 4x4 matrix. See the article on  homogeneous coordinates  for some advantages in using 4x4 matrices to represent transformations. Applying transformations Most math.gl classes offer a  transform  method that accepts matrices and quaternions. The various vector classes also offer methods to transform with smaller matrices Quaternion transformations are also supported on some objects Note that  <object>.transform()  operations modify the object being transformed (and also return the modified object to enable \"chaining\" of calls). Alternatively, transformations can also be performed via the matrix and quaternion classes. In this case, the transformation is stored in the result parameters (a new array is allocated if it  result  is not supplied.) Types of Transformations The basic transformations are rotations, scalings, and translations. Composing Transformations One of the most powerful aspects of using matrices to manage transformations is that matrices can be multiplied together using linear algebra. This allows us to build up a complex transformation by multiplying together component parts. Matrix4  provides a number of transformation methods ('scale', 'rotate', 'translate', ...) that allow us to build transformation matrices. These can be applied to an identity matrix (e.g. a newly created  Matrix4 ) or to a matrix that already contains other transformations. Order Matters When composing (i.e. multiplying) matrices it is critical to consider the order in which they are being applied, as changing the order of component will in most cases change the resulting composite transformation. It is not hard to verify that this is consistent with geometric intuition by composing a few operations on paper. Because of this the  Matrix4  class provides two matrix multiplication methods:  multiplyLeft  and  multiplyRight  that force you to make explicit what you intend when multiplying two matrices. All  Matrix4  transformation methods ('scale', 'rotate', 'translate', ...) conceptually correspond to multiplying in a new transformation matrix from the right (although these methods internally are more efficient in that they don't create any temporary objects and they only do the minimal amount of changes to the matrix required for that specific transformation). In the end, the point or vector to be transformed will be multiplied in from the right, which means that a typical composed transformation needs to be read in reverse order. I.e. in the example below, the vector will first be rotated, then transformed by the  partialTransform , then scaled. About Rotations For more in-depth background about rotations, see the separate article on  rotations . If you have a vector with 3 elements you can rotate it around an axis and a point like so: Decomposing Transformations The ability to compose transformations naturally leads to the possibility of  decomposing  a composite transformations into its constituent parts. This is possible, with certain caveats (not all matrices are directly decomposable into rotation, translation and scale. Shear is currently not handled). Sepcifically, the math.gl  Matrix4  object exposes the  getScale ,  getTranslation  and  getRotation  (or  getRotationMatrix3 ) methods are provided for this purpose:","headings":[{"value":"Transformations","depth":1},{"value":"Representing Transformations","depth":2},{"value":"Applying transformations","depth":2},{"value":"Types of Transformations","depth":2},{"value":"Composing Transformations","depth":2},{"value":"Order Matters","depth":2},{"value":"About Rotations","depth":2},{"value":"Decomposing Transformations","depth":2}],"slug":"modules/core/docs/developer-guide/transformations","title":"Transformations"},{"excerpt":"3D Coordinate Systems This article is a work in progress. There are many possible ways to represent points in space using coordinates, e.g. rectangular, elliptical, polar/spherical, etc. Which coordinate system is the best depends entirely on the problem at hand. When working with specific geometrical problems, it is often the case that the required mathematical operations become more simple in a certain coordinate system which means that it is worth being familiar both with a few different coordinate system and also how to convert between them. math.gl provides support for a couple of 3D coordinate systems: Rectilinear ( Vector3 ) - Typically used to represent standard Cartesian space Spherical ( SpericalCoordinates ) - Two angles representing point on sphere and a distance from center Projective/Homogeneous ( Vector4 ) - These are coordinates in \"projective\" 3-space. The purpose of these is explained in  link Converting between Coordinate Systems Note that each coordinate system ultimately specifies the same point Converting within Coordinate Systems Remarks Note that a similar situation applies for  rotations , where different representations are possible (e.g. Euler angles, Quaternions, Axis/angle, 4x4 matrices) and the choice of a \"best\" representation often depends on the problem at hand.","headings":[{"value":"3D Coordinate Systems","depth":1},{"value":"Converting between Coordinate Systems","depth":2},{"value":"Converting within Coordinate Systems","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/concepts/coordinate-systems","title":"3D Coordinate Systems"},{"excerpt":"Homogeneous Coordinates This article is a work in progress. The math.gl  Vector4  class is not normally used to represent four dimensonal points. Instead it is intended to be used to calculate with 3 dimensonal  homogeneous coordinates , as defined by projective geometry. Mathematically, in projective geometry, each  Vector4  is interpreted as a point on a 3D line through the origin. And it is this line that is the primary object, in the sense that the point is only considered to be one of infinintely many \"representatives\" of that a line through the origin. Dividing  xyz  with the same number will generate another point, or 'representative' of the same line The main reason homogeneous coordinates and projective geometry are used in 3D graphics programming is that they allow perspective projection and translations to be represented as linear transformations using 4x4 matrices. The W Coordinate Mathematically, homogeneous coordinates add one extra dimension to represent a number. In the 3 dimensional computer graphics case, it is customary to refer to the extra (4th) components as  w . Mathematically, the  w  coordinate indicates which representative along the projective line. There is a straightforward graphical interpretation of the  w  coordinate: During projection of a set of homogeneous vectors onto a plane at distance 1 from the origin, all the vectors are normalized so that their  w  coordinates are  1  by dividing  xyz  with  w . which leads to the following graphical interpretation: w Graphical Interpretation >  1 your object will look smaller <  1 your object will look bigger =  0 will cause a crash or undefined behavior <  0 will flip your object (upside-down, back-to-front, ...) Both math.gl and typical GPUs do not support calculations on homogeneous coordinates with a  w  component of zero. (However, zero  w coordinates play a very important role in general projective geometry, see \"Background\" below). Practical Usage Projective Transformation A general projective transformation matrix has the following format Translation of 3D coordinates Linear transformations on a vector space can not move the origin, they can only scale and rotate. Translations leave the  w  coordinate unchanged. As can be seen in the general format of the projection matrix, setting  w  to 0 prevents a vector from picking up the translations when multiplied with a 4x4 matrix. (easy to see as the translations are stored in the final column of the transposed matrix) Perspective Transformation Note that in general, a perspective transformation (i.e. multipliying) do change the  w  coordinate of the  Vector4 , so vectors must be \"scaled\" after transformation when used in JavaScript. GPU Note: the GPU automatically divides  vec4   xyz  components with  w  when they are returned from the vertex shader (when homogeneous coordinates are returned from the vertex shader (typically by assigning a  vec4  to  gl_Position ). This can be an important detail to be aware of when comparing JavaScript and GLSL code, and also when working in screen space (post-projection) in the vertex shader, in which case you typically do need to perform the  w  scaling yourself. Background Information Some fun facts to provide additional context around homogeneous coordinates. Projective geometry was coordinatized (in the form or homogeneous coordinates) in the early 1800s by Plücker and Möbius, almost 200 years after the coordinatization of \"affine\" geometry by Descartes. There is a special  notation  for homogeneous coordinate vectors that emphasizes the relative aspect of the values: However, in mathematics, one of the most important aspects of projective geometry is that it can be used to avoid handling of  special cases  (this aspect is not used in math.gl). Essentially, in contrast to line equations in affine geometry, projective geometry allows parallel lines to be represented by adding a set of additional points in the form of a \"plane at infinity\" (which is represented by  w = 0 ). This is powerful as it makes it possible to e.g. make statements about geometry (such as two lines always meet in one point) without having to make tedious exceptions for parallel lines.","headings":[{"value":"Homogeneous Coordinates","depth":1},{"value":"The W Coordinate","depth":3},{"value":"Practical Usage","depth":2},{"value":"Projective Transformation","depth":3},{"value":"Translation of 3D coordinates","depth":3},{"value":"Perspective Transformation","depth":3},{"value":"Background Information","depth":2}],"slug":"modules/core/docs/concepts/homogeneous-coordinates","title":"Homogeneous Coordinates"},{"excerpt":"View and Projection Matrices One of the major functions of any 3D math library is to let applications create view and projection matrices to enable positioning of the viewer in a 3D world and projection of a field-of-view onto a flat \"screen\". View and Projection Matrices To set up a 4x4 view projection matrix you need a view matrix (specifying the position, direction and orientation of the camera) and a projection matrix (specifying the characteristics of the camera such as its field of view etc). The purpose of the view matrix is to translate and rotate your world coordinates so that the eye is located in the origin  [0, 0, 0] , looking down the positive  Z  axis, rotated so that the right direction is  up . This is called the \"view coordinate system\". The purpose of the projection matrix is to transform from view coordinates to \"clipspace\" coordinates (which is the only coordinate system that the GPU can work directly with). If a point is between  -1  and  1  (after  w  scaling) in clipspace, it will be rendered. The  z  coordinate in clipspace is also scaled (using 'near' and 'far' planes) and if between  -1  and  1  it is used for depth test. Note: while a projection matrix may generate coordinates with  w !== 1 , the GPU will automatically divide the  xyzw  coordinates with the  w  coordinateof any positions it receives thus and \"normalize\" the  w  coordinate. Thus, there is no need to do this scaling manually in shaders unless doing additional arithmetic in clipspace. Creating a View Matrix To create a view matrix Matrix4.lookAt({...}) Normally positions are transformed by the view matrix. If doing work (e.g. lighting) in view space you will also want to transform other geometry such as normals. Projection Matrices Projection matrices typically show everything inside a frustum (truncated pyramid) or a cube in the view space. Their job is to \"scale\" or \"skew\" the geometry inside this virtual shape into the clipspace cube, which is the coordinate system the GPU takes as input. Perspective Projection Matrix To create a projection matrix use: Matrix4.perspective({fov, aspect, near, far}) Creating an Orthographic Projection Matrix math.gl provides the traditional function create an orhtographic projection matrix by providing the \"box\" extents: Matrix4.ortho({right, left, top, bottom, near, far}) The extents are specified in \"view space\" (which is typically translated and rotated, but not scaled, world space). Switching between Perspective and Orthographic Views In applications it is not unusual to want to offer both perspective and orthographic views. To support this case, math.gl offers an additional method for creating orthographic projection matrix, that takes the same parameters as  Matrix4.perspective() , with the addition of one additional parameter,  focalDistance  that selects which plane in the perspective view frustum should be used to calculate the size of the orthographic view box. Matrix4.orthographic({fovy, aspect, focalDistance, near, far}) About Projection Matrices An ortograhic projection matrix essentially just scales your view to show everything within a box. As can be seen in the matrix below, it just centers your view between the bounds of the box, and scales your positions so that the box limits fall on -1 and +1 in each direction. It also does an inversion of the X and Y coordinates. Decomposing a ViewProjection Matrix TBA Remarks As always, matrices are presented here in row major notation, however math.gl stores them internally in column major format to match WebGL requirements.","headings":[{"value":"View and Projection Matrices","depth":2},{"value":"View and Projection Matrices","depth":2},{"value":"Creating a View Matrix","depth":3},{"value":"Projection Matrices","depth":2},{"value":"Perspective Projection Matrix","depth":3},{"value":"Creating an Orthographic Projection Matrix","depth":3},{"value":"Switching between Perspective and Orthographic Views","depth":3},{"value":"About Projection Matrices","depth":2},{"value":"Decomposing a ViewProjection Matrix","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/developer-guide/view-and-projection","title":"View and Projection Matrices"},{"excerpt":"Euler A class to handle Euler rotation. More information on rotation using a Euler vector can be found  here . Generally speaking the three components of the Euler object represents the roll, pitch and yaw angles and the rotation is applied according to a specific rotation order. Usage Constants Euler.ZYX Euler.YXZ Euler.XZY Euler.ZXY Euler.YZX Euler.XYZ Euler.RollPitchYaw Euler.DefaultOrder  (=  Euler.ZYX ) Euler.RotationOrders  =  ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'] ; Members x, y z x, y, z angle notation (note: only corresponds to axis in XYZ orientation) roll, pitch, yaw roll, pitch, yaw angle notation alpha, beta, gamma alpha, beta, gamma angle notation phi, theta, psi phi, theta, psi angle notation order rotation order in all notations Methods constructor (x = 0, y = 0, z = 0, order = Euler.DefaultOrder) Number|Number[], Number, Number, Number fromRollPitchYaw Common ZYX rotation order euler.fromRollPitchYaw(roll, pitch, yaw) fromRotationMatrix euler.fromRotationMatrix(m, order = Euler.DefaultOrder) fromQuaternion euler.fromQuaternion(q, order) copy If copied array does contain fourth element, preserves currently set order. euler.copy(array) set Sets the three angles, and optionally sets the rotation order. If order is not specified, preserves currently set order. euler.set(x = 0, y = 0, z = 0, order) toArray Does not copy the orientation element euler.toArray(array = [], offset = 0) toArray4 Copies the orientation element euler.toArray4(array = [], offset = 0) toVector3 euler.toVector3(optionalResult) fromVector3 euler.fromVector3(v, order) fromArray euler.fromArray(array, offset = 0) getRotationMatrix euler.getRotationMatrix(m = new Matrix4()) Returns  Matrix4  - a rotation matrix corresponding to rotations per the specified euler angles getQuaternion euler.getQuaternion() Remarks Attribution: inspired by THREE.js  THREE.Euler  class","headings":[{"value":"Euler","depth":1},{"value":"Usage","depth":2},{"value":"Constants","depth":2},{"value":"Members","depth":2},{"value":"x, y z","depth":3},{"value":"roll, pitch, yaw","depth":3},{"value":"alpha, beta, gamma","depth":3},{"value":"phi, theta, psi","depth":3},{"value":"order","depth":3},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"fromRollPitchYaw","depth":3},{"value":"fromRotationMatrix","depth":3},{"value":"fromQuaternion","depth":3},{"value":"copy","depth":3},{"value":"set","depth":3},{"value":"toArray","depth":3},{"value":"toArray4","depth":3},{"value":"toVector3","depth":3},{"value":"fromVector3","depth":3},{"value":"fromArray","depth":3},{"value":"getRotationMatrix","depth":3},{"value":"getQuaternion","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/api-reference/euler","title":"Euler"},{"excerpt":"MathArray Usage MathArray  is a base class, and should not be instantiated directly. Cloning an object Scaling with constants Scaling with vectors is very flexible, you can e.g. set a component to zero, or flip a component's sign. Methods clone array.clone() copy array.copy(array) set array.set(...args) fromArray array.fromArray(array, offset = 0) toString Calls  formatString  with the global math.gl config. array.toString() formatString array.formatString(config) toArray array.toArray(array = [], offset = 0) toFloat32Array array.toFloat32Array() equals array.equals(array) exactEquals array.exactEquals(array) length array.length() lengthSquared array.lengthSquared() distance array.distance(mathArray) distanceSquared array.distanceSquared(mathArray) normalize array.normalize() validate Checks if a  MathArray  contains valid values. array.validate(array = this) Returns  false  if any value fails  Number.isFinite  test. check If  config.debug  is true, validates the  MathArray  and throws an error if it does not contains valid values. array.check(array = this) Mote: This method is called by all mutating methods.","headings":[{"value":"MathArray","depth":1},{"value":"Usage","depth":2},{"value":"Methods","depth":2},{"value":"clone","depth":3},{"value":"copy","depth":3},{"value":"set","depth":3},{"value":"fromArray","depth":3},{"value":"toString","depth":3},{"value":"formatString","depth":3},{"value":"toArray","depth":3},{"value":"toFloat32Array","depth":3},{"value":"equals","depth":3},{"value":"exactEquals","depth":3},{"value":"length","depth":3},{"value":"lengthSquared","depth":3},{"value":"distance","depth":3},{"value":"distanceSquared","depth":3},{"value":"normalize","depth":3},{"value":"validate","depth":3},{"value":"check","depth":3}],"slug":"modules/core/docs/api-reference/math-array","title":"MathArray"},{"excerpt":"Matrix Matrix  is a base class for  Matrix3  and  Matrix4 , providing common methods to those classes. Methods toString() Returns a string representation of the matrix setElement(): this Sets the element at \"conceptual position\"  M[i][j] , row major indices by default matrix3.set(i, j, value, columnMajor = false) getElement(): number Gets the element at \"conceptual position\"  M[i][j] , row major indices by default matrix3.get(i, j, columnMajor = false) getColumn(columnIndex: number [ , result: number 3 ]): number 3 Extracts a column from the matrix setColumn(columnIndex: number, columnVector: number 3 ): Matrix Copies a column into the matrix","headings":[{"value":"Matrix","depth":1},{"value":"Methods","depth":2},{"value":"toString()","depth":3},{"value":"setElement(): this","depth":3},{"value":"getElement(): number","depth":3},{"value":"getColumn(columnIndex: number [ , result: number3]): number3","depth":3},{"value":"setColumn(columnIndex: number, columnVector: number3): Matrix","depth":3}],"slug":"modules/core/docs/api-reference/matrix","title":"Matrix"},{"excerpt":"3D Rotations This article is a work in progress. math.gl provides a \"standard 3D library complement\" of mathematical classes for handling rotations in 2D and 3D, such as classes for manipulating  Euler  angles and  Quaternion s. As in any 3D math library, the key goals are enabling applications to easily and intuitively specify (parametrize) rotations, combine them with other rotations and other transformations, and ultimately transform points with the rotations or resulting transformations. While math.gl is intended to help programmers' implement the typical 3D application's rotation functionality with a minimum amount of knowledge, and does not even attempt to support rotations in more than 3 dimensions, it should be pointed out that the mathematical treatment of rotations can be very complicated. For some context on this see the background section at the end of this article. Properties of 3D Rotations In contrast to 2D rotations, 3D rotations are not order-independent, meaning that applying the same two rotations in different order will often yield different results. However, by  Euler's Rotation Theorem , two 3D rotations around the origin can always be expressed as (combined into) another single 3D rotation around the origin. A 3D rotation requires a minimum of three values to be fully specified (and even then can require careful definitions of which conventions are used). Also, a simple observation: Rotations around arbitrary points can be treated as rotations around the origin simply by applying a translation before the rotation, and the inverse translation after the rotation. Therefore, for simplicity, this discussion focuses solely on rotations around the origin. Parametrizing 3D Rotations A minimum of three values are required to fully specify a 3D rotation (another result of Euler's), e.g, Euler angles or unit quaternions. However in many cases the best way to specify a rotation is to use four parameters: an axis and an angle. Representation Interpolation Addition Transforming points Vector/Angle - - Good Quaternion Excellent Excellent Good 4x4 Matrix - Excellent Excellent Euler angle - - - Rotation Axis and Angle Per the Euler Rotation Theorem, any two 3D rotations can be combined into a single 3D rotation. A single 3D rotation happens around an axis, and the rotation is a certain angle. This means that it is possible to specify a rotation using four very understanable values: an axis and an angle. Euler Angles One of the more \"human readable\" representation of a 3D rotation is the \"Euler angle\", simplistically, an \"Euler angle\" completely specifies a rotation using only 3 values, which are all \"human readable\" angles around the three coordinate axes, which is very appealing. However, the conventions for  Euler angle values  can vary in a number of ways. Following three.js, the math.gl  Euler  class uses intrinsic Tait-Bryan angles. Note that the large number of representations means that Euler angles exchanged between e.g. different software systems may not be directly compatible (and in addition, converting between the various representations is not exactly easy), so unless care is taken this can cause \"mind-numbing\" confusion. Because of the variability, a good approach is often to be extremely careful when importing and exporting Euler angles from your code, and convert angle Euler angles to Matrix or Quaternion representations (which are much less ambiguous) for further manipulation. Unit Quaternions \"Unit quaternions\" are normally the best representation for \"manipulation\" of 3D rotations. Manpulation here mainly refers to the \"composition\" or \"addition\" and interpolation of rotations. Note that unit quaternions are simply quaternions of norm (or length) equal to  1 , and while a general quaternion (as the name suggests) contains four components, a unit quaternion needs only three values to be fully specified. Unit quaternions can be used to model 3 dimensional rotations. qr v qr-1 Interpolation of quaternions is done using Spherical Linear intERPolation (aka SLERP). Rotation Matrices When combining rotations with other transformations (translations, scalings, projections etc), 4x4 matrices are the representation of choice. Properties of Rotation Matrices A rotation matrix T\nRR = I Note that a matrix R satisfying this can also include an inversion (improper rotation matrix) Converting between Rotation Representations Executing Rotation Transformations While Euler angles are often a good way to specify 3D rotations, they can not directly be used to transfor points or vectors. To do that, they have to be converted to . Rotations using Rotation Matrices A rotation matrix T\nRR = I Combining Rotations The fact that rotations. They can either be combined as w Math with Euler Angles Math with Quaternions Interpolating Rotations To avoid issues with gimbal locks and flips, it is recommended to use quaternions when interpolating rotations. Calculate the quaternion that represents the rotation you want to apply (e.g. moves the start rotation to the target rotation), and then just interpolate q with the identity quaternion using  slerp() . The resulting quaternion can then be used directly to transform  Vector s or it can be transformed into a  Matrix4  transformation matrix. Background: Rotations are Complicated If you are new to working with rotations and the amount of complications outlined in this article seem overwhelming, take some comfort in the fact that rotations in three and higher dimensional spaces are indeed quite complicated to treat mathematically. As an example, several fundamental properties of rotations are highly dependent on the number of dimensions involved. To help the reader who has not worked extensively with rotations build some \"intuition\" for the fact that 3D rotations are non-trivial, the following summary shows how the nice, structured properties of 2D rotations gradually disappear as the number of dimensions increase: In two dimensions, rotations are highly structured and intuitive: A series of 2D rotations can be applied in any order (they commute). Any 2D rotation can be fully parametrized by a single value (the \"angle\").\nThe combination of two 2D rotations can always be expressed as another single rotation (simply by taking the sum of the angles of the two rotations). In three dimensions rotation start to loose some structure:\n  In 3D, rotations are no longer order-independent (they are not commutative), meaning that applying the same two rotations in different order will often yield different results.\n  However, by  Euler's Rotation Theorem , two 3D rotations around the origin can still always be expressed as (combined into) another single 3D rotation around the origin.  *  Also, a 3D rotation requires not two, but a minimum of three values to be fully specified. To give some contrast, in four and higher dimensions: Naturally, rotations still no longer commutative. And worse: Euler's Rotation Theorem no longer holds. There are now two different types of basic rotations, and the combination of two rotations will in general not result in another \"rotation\", but another, more complex transformation. In addition, the number of parameters (degrees of freedom) required to fully specify a rotation grows with mind-boggling rapidity, as 2^(n-1) - 1, meaning that e.g. a \"21 dimensional rotation\" would require over one million values to be fully specified! Background: More on Euler Angles Euler angle values Axis Order  - the order of rotations needs to be defined. There are 6 ways to order rotations around the three axis. Choice of Axes  - \"Classic Euler\" angles follow a Z-Y-Z, convention, rotating around the same angle first and last. However, in modern applications (e.g. Aerospace and Nautical), the \"Tait-Brya\" Intrinsic or Extrinsic  - One one also needs to define whether the angles are intrinsic or extrinsic.\nAs a comparison: three.js  Euler  class uses intrinsic Tait-Bryan angles. \"Intrinsic\" means that rotations are performed with respect to the local coordinate system. That is, for order 'XYZ', the rotation is first around the local-X axis (which is the same as the world-X axis), then around local-Y (which may now be different from the world Y-axis), then local-Z (which may be different from the world Z-axis). Remarks In this article, the word \"axes\" represents the plural of a (coordinate) \"axis\" (normally, the word \"axes\" refers to the X, Y and Z coordinate axes). Note  that one of the most efficient way to specify rotations is to use the Euler-Rodrigues parameters, which has some of the quaternion representation without requiring the introduction of quaternion algebra. math.gl does not directly support this representation though although the vector/angle can easily be converted.","headings":[{"value":"3D Rotations","depth":1},{"value":"Properties of 3D Rotations","depth":3},{"value":"Parametrizing 3D Rotations","depth":2},{"value":"Rotation Axis and Angle","depth":3},{"value":"Euler Angles","depth":3},{"value":"Unit Quaternions","depth":3},{"value":"Rotation Matrices","depth":2},{"value":"Properties of Rotation Matrices","depth":2},{"value":"Converting between Rotation Representations","depth":2},{"value":"Executing Rotation Transformations","depth":2},{"value":"Rotations using Rotation Matrices","depth":2},{"value":"Combining Rotations","depth":2},{"value":"Interpolating Rotations","depth":2},{"value":"Background: Rotations are Complicated","depth":2},{"value":"Background: More on Euler Angles","depth":2},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/concepts/rotations","title":"3D Rotations"},{"excerpt":"Pose A 6-degree-freedom pose (3D position and 3D rotation).\nSee  Tait–Bryan angles : z-y'-x\" Usage Members x, y z Gets or sets position components respectively roll, pitch, yaw Gets or sets rotation components respectively Methods constructor x ,  y ,  z  - position roll ,  pitch ,  yaw  - rotation in radians position  -  Vector3  or array of 3 that represents the position orientation  -  Euler  or array of 4 that represents the rotation getPosition pose.getPosition() Returns  Vector3 . getOrientation pose.getOrientation() Returns  Euler . equals pose.equals(otherPose) exactEquals pose.exactEquals(otherPose) getTransformationMatrix pose.getTransformationMatrix() Returns a 4x4 matrix that transforms a coordinates (in the same\ncoordinate system as this pose) into the \"pose-relative\" coordinate\nsystem defined by this pose. The pose relative coordinates with have origin in the position of this\npose, and axis will be aligned with the rotation of this pose. Returns  Matrix4 . getTransformationMatrixFromPose pose.getTransformationMatrixFromPose(otherPose) Given a second pose that represent the same object in a second coordinate\nsystem, this method returns a 4x4 matrix that transforms coordinates in the\nsecond coordinate system into the coordinate system of this pose. Returns  Matrix4 . getTransformationMatrixToPose pose.getTransformationMatrixToPose(otherPose) Given a second pose that represent the same object in a second coordinate\nsystem, this method returns a 4x4 matrix that transforms coordinates in the\ncoordinate system of this pose into the coordinate system of the second pose. Returns  Matrix4 .","headings":[{"value":"Pose","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"x, y z","depth":3},{"value":"roll, pitch, yaw","depth":3},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"getPosition","depth":3},{"value":"getOrientation","depth":3},{"value":"equals","depth":3},{"value":"exactEquals","depth":3},{"value":"getTransformationMatrix","depth":3},{"value":"getTransformationMatrixFromPose","depth":3},{"value":"getTransformationMatrixToPose","depth":3}],"slug":"modules/core/docs/api-reference/pose","title":"Pose"},{"excerpt":"Matrix3 A 3x3 matrix. Any arguments can be plain JavaScript arrays or other  math.gl  objects. Usage Copy a matrix to a  Matrix3  so that it can be manipulated (and mutated) with  Matrix3  methods: Invert a matrix Transform a vector as a point (including translations) Transform a vector as a direction (NOT including translations) Inheritance class Matrix3 extends [Matrix](./docs/api-reference/matrix) extends [MathArray](./docs/api-reference/math-array) extends [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) Methods Many of the most commonly used methods are inherited from  MathArray : matrix3.clone() matrix3.copy(array) matrix3.set(...args) matrix3.fromArray(array, offset = 0) matrix3.toString() matrix3.toArray(array = [], offset = 0) matrix3.equals(array) matrix3.exactEquals(array) matrix3.validate(array = this) matrix3.check(array = this) matrix3.normalize() Note that  Matrix3  is a subclass of the built in JavaScript  Array  and can thus e.g. be supplied as a parameter to any function expecting an  Array . constructor() Creates an empty  Matrix3 new Matrix3() identity(): this Sets the matrix to the multiplicative identity matrix. matrix3.identity() set(...number): this Sets the elements of the matrix. matrix3.set(m00, m01, m02, m10, m11, m12, m20, m21, m22) fromQuaternion(q: Quaternion): this Sets the matrix to a transformation corresponding to the rotations represented by the given quaternion. matrix3.fromQuaternion(quaternion) quaternion  ( Quaternion ) - the quaternion to create matrix from determinant(): number Returns the determinant of the matrix (does not modify the matrix). const determinant = matrix3.determinant() Returns ( Number ) - the determinant If the determinant is zero, the matrix is not invertible. Determinant calculation is somewhat expensive. transpose(): this Sets this matrix to its transpose matrix. matrix3.transpose() The transpose matrix mirrors the original matrix elements in the diagonal. invert(): this Sets this matrix to its inverse matrix. matrix3.invert() The inverse matrix times its original matrix is an identity matrix of the same size. multiplyLeft(matrix: number 9 ): this Multiplies in another matrix from the left matrix3.multiplyLeft(matrix3) When using  Matrix3  to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course). multiplyRight(matrix: number 9 ): this matrix3.multiplyRight(matrix3) When using  Matrix3  to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course). rotate(): this Adds a rotation by the given angle. Equivalent to right multiplying the new transform into the matrix but more performant. matrix3.rotate(radians) scale(factor: number 2 ): this Adds a scaling transform, each axis can be scaled independently. matrix3.scale(factor) factor  (Number) - scale factor to be applied to each axis. matrix3.scale([x, y]) x  (Number) - scale factor to be multiplied into x component y  (Number) - scale factor to be multiplied into y component Equivalent to right multiplying the new transform into the matrix but more performant. During vector transformation all coordinates will be multiplied with the given factors. Scale with  -1  will flip the coordinate system in that axis. Scale with  0  will drop that component. translate(offset: number 2 ): this Adds a translation to the matrix. matrix3.translate([x, y]) x  (Number) - translation to be added to the x component y  (Number) - translation to be added to the y component Equivalent to right multiplying the new transform into the matrix but more performant. During vector transformation the given translation values are added to each component of the vector being transformed. transformVector() transformVector(vector, out) vector  ( Array | Vector2 | Vector3 ) out  - unless supplied, will be a  Vector2  or  Vector3 , matching the length of input vector.\nReturns  out , or a newly minted  Vector2  or  Vector3 . Remarks All transforms are effectively \"right multiplied\" onto the matrix (meaning that during transform they will be applied in opposite order). Matrix3  is stored internally in column major format (per WebGL conventions). This only matters when you read out the matrix to use it with other software.","headings":[{"value":"Matrix3","depth":1},{"value":"Usage","depth":2},{"value":"Inheritance","depth":2},{"value":"Methods","depth":2},{"value":"constructor()","depth":3},{"value":"identity(): this","depth":3},{"value":"set(...number): this","depth":3},{"value":"fromQuaternion(q: Quaternion): this","depth":3},{"value":"determinant(): number","depth":3},{"value":"transpose(): this","depth":3},{"value":"invert(): this","depth":3},{"value":"multiplyLeft(matrix: number9): this","depth":3},{"value":"multiplyRight(matrix: number9): this","depth":3},{"value":"rotate(): this","depth":3},{"value":"scale(factor: number2): this","depth":3},{"value":"translate(offset: number2): this","depth":3},{"value":"transformVector()","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/api-reference/matrix3","title":"Matrix3"},{"excerpt":"Matrix4 A 4x4 matrix. Any arguments to  Matrix4  methods can be plain JavaScript arrays or other  math.gl  objects. Usage Copy a matrix to a  Matrix4  so that it can be manipulated (and mutated) with  Matrix4  methods: Create a perspective projection matrix Create an orthograhic projection matrix Invert a matrix Transform a vector as a point (including translations) Transform a vector as a direction (NOT including translations) Inheritance class Matrix4 extends   Matrix   extends   MathArray   extends   Array ` Many basic methods are inherited: matrix4.clone() matrix4.copy(array) matrix4.set(...args) matrix4.fromArray(array, offset = 0) matrix4.toString() matrix4.toArray(array = [], offset = 0) matrix4.equals(array) matrix4.exactEquals(array) matrix4.validate(array = this) matrix4.check(array = this) matrix4.normalize() Since  Matrix4  is a subclass of the built in JavaScript  Array  it can be used directly as a parameter to any function expecting an  Array . Methods constructor() Creates an empty  Matrix4 new Matrix4() identity(): this Sets the matrix to the multiplicative identity matrix. matrix4.identity() set(...number): this Sets the elements of the matrix. matrix4.set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) fromQuaternion(quaternion: Quaternion): this Sets the matrix to a transformation corresponding to the rotations represented by the given quaternion. matrix4.fromQuaternion(quaternion) quaternion  ( Quaternion ) - the quaternion to create matrix from frustum(options: {left: number, right: number, bottom: number, top: number, near: number, far: number}): this Generates a frustum matrix with the given bounds. The frustum far plane can be infinite. matrix4.frustum({left, right, bottom, top, near, far}) left  ( number ) - Left bound of the frustum right  ( number ) - Right bound of the frustum bottom  ( number ) - Bottom bound of the frustum top  ( number ) - Top bound of the frustum near  ( number ) - Near bound of the frustum far  ( number | Infinity ) - Far bound of the frustum lookAt(options?: {eye: number, center: number, up: number}): this Generates a look-at matrix with the given eye position, focal point, and up axis matrix4.lookAt({eye, center, up}) eye  ( Vector3 | number[3] ) - Position of the viewer center  ( = ) - 0, 0, 0] vec3 Point the viewer is looking at up  ( = ) - 0, 1, 0] vec3 vec3 pointing up ortho(options: {left: number, right: number, bottom: number, top: number, near?: number, far: number}): this Generates a orthogonal projection matrix with the given bounds matrix4.ortho({left, right, bottom, top, near = 0.1, far = 500}) left  ( number ) - Left bound of the frustum right  ( number ) - Right bound of the frustum bottom  ( number ) - Bottom bound of the frustum top  ( number ) - Top bound of the frustum near  ( number ) - Near bound of the frustum far  ( number ) - Far bound of the frustum orthographic Generates an orthogonal projection matrix with the same parameters\nas a perspective matrix (plus  focalDistance ). Matrix4.orthographic({fovy, aspect, focalDistance, near, far}) fovy  ( number ) - Vertical field of view in radians aspect  ( number ) - Aspect ratio. typically viewport width/height focalDistance  ( number ) - selects which plane in the perspective view frustum should be used to calculate the size of the orthographic view box. near = 0.1  ( number ) - Near bound of the frustum far = 500  ( Nmber ) - Far bound of the frustum In applications it is not unusual to want to offer both perspective and orthographic views and this method is supplied to make this as simple as possible. perspective Generates a perspective projection matrix with the given bounds. The frustum far plane can be infinite. matrix4.perspective({ fovy = 45 * Math.PI - / 180, aspect = 1, near = 0.1, far = 500 }) fovy = 45  ( number ) - Vertical field of view in radians (default is 45 degrees specified in radians) aspect = 1  ( number ) - Aspect ratio. typically viewport width/height near = 0.1  ( number ) - Near bound of the frustum far = 500  ( number | Infinity ) - Far bound of the frustum determinant(): number Returns the determinant of the matrix (does not modify the matrix). const determinant = matrix4.determinant() Returns ( number ) - the determinant If the determinant is zero, the matrix is not invertible. Determinant calculation is somewhat expensive. transpose(): this Sets this matrix to its transpose matrix. matrix4.transpose() The transpose matrix mirrors the original matrix elements in the diagonal. invert(): this Sets this matrix to its inverse matrix. matrix4.invert() The inverse matrix mirrors the original matrix elements in the diagonal. multiplyLeft(matrix: number 16 ): this Multiplies in another matrix from the left matrix4.multiplyLeft(matrix4) When using  Matrix4  to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course). multiplyRight(matrix: number 16 ): this matrix4.multiplyRight(matrix4) When using  Matrix4  to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course). rotateX(radians: number): this Adds a rotation by the given angle around the X axis. Equivalent to right multiplying the new transform into the matrix but more performant. matrix4.rotateX(radians) rotateY(radians: number): this Adds a rotation by the given angle around the Y axis. rotateY(radians) Equivalent to right multiplying the new transform into the matrix but more performant. rotateZ(radians: number): this Adds a rotation by the given angle around the Z axis. matrix4.rotateZ(radians) Equivalent to right multiplying the new transform into the matrix but more performant. rotateXYZ(angles:  rx: number, ry: number, rz: number ): this Adds successive rotations by the given angles around the X, Y and Z axis. rotateXYZ([rx, ry, rz]) Equivalent to right multiplying the new transform into the matrix but more performant. rotateAxis(radians: number, axis: number 3 ): this Adds successive rotations by the given angles around the X, Y and Z axis. rotateAxis(radians, axis) Equivalent to right multiplying the new transform into the matrix but more performant. scale(factor: number | number 3 ): this Adds a scaling transform, each axis can be scaled independently. matrix4.scale(factor) factor  (number) - scale factor to be applied to each axis. matrix4.scale([x, y, z]) x  (number) - scale factor to be multiplied into x component y  (number) - scale factor to be multiplied into y component z  (number) - scale factor to be multiplied into z component Equivalent to right multiplying the new transform into the matrix but more performant. During vector transformation all coordinates will be multiplied with the given factors. Scale with  -1  will flip the coordinate system in that axis. Scale with  0  will drop that component. translate(scale: number 3 ): this Adds a translation to the matrix. matrix4.translate([x, y, z]) x  (number) - translation to be added to the x component y  (number) - translation to be added to the y component z  (number) - translation to be added to the z component Equivalent to right multiplying the new transform into the matrix but more performant. During vector transformation the given translation values are added to each component of the vector being transformed. Decomposition getRotation(result?: number 16 ) : number 16 Returns a 4x4 rotation matrix. getRotationMatrix3(result?: number 9 ) : number 9 Returns a 3x3 rotation matrix. getTranslation(result?: number 3 ) : number 3 Returns the 3-element translation vector component of the affine transform described by the matrix. For performance, an existing vector can be provided, if not a new vector will be returned. getScale(result?: number 3 ) : number 3 Returns the 3-element scale vector component of the affine transform described by the matrix. For performance, an existing vector can be provided, if not a new vector will be returned. Point Transformations transformAsPoint(vector : number 4 ) : number 4 Transforms any 2, 3 or 4 element vector as a \"point\" by multiplying it (from the right) with this matrix.  Point  here means that the returned vector will include any translations in this matrix. const vector = matrix4.transformPoint(vector, out=) vector  ( Array | Vector2 | Vector3 | Vector4 ) out  - unless supplied, will be a Vector2, Vector3 or Vector4, matching the length of input vector.\nReturns  out , or a newly minted  Vector2 ,  Vector3  or  Vector4 If  vector  is specified in homogeneous coordinates,  w  coordinate must NOT be  0 . If  vector  is specified in homogeneous coordinates the returned vector will be  w  adjusted, (i.e.  w  coordinate will be  1 , even if the supplied vector was not normalized). transformAsVector(vector : number 4 ) : number 4 Transforms any 2, 3 or 4 element vector interpreted as a direction (i.e. all vectors are based in the origin so the transformation not pick up any translations from the matrix). const vector = matrix4.transformDirection(vector, out) If  vector  is specified in homogeneous coordinates,  w  coordinate must be  0 . Remarks All transforms are effectively \"right multiplied\" onto the matrix (meaning that during transform they will be applied in opposite order). Matrix4  is stored internally in column major format (per WebGL conventions). This only matters when you read out the matrix to use it with other software.","headings":[{"value":"Matrix4","depth":1},{"value":"Usage","depth":2},{"value":"Inheritance","depth":2},{"value":"Methods","depth":2},{"value":"constructor()","depth":5},{"value":"identity(): this","depth":5},{"value":"set(...number): this","depth":5},{"value":"fromQuaternion(quaternion: Quaternion): this","depth":5},{"value":"frustum(options: {left: number, right: number, bottom: number, top: number, near: number, far: number}): this","depth":5},{"value":"lookAt(options?: {eye: number, center: number, up: number}): this","depth":5},{"value":"ortho(options: {left: number, right: number, bottom: number, top: number, near?: number, far: number}): this","depth":5},{"value":"orthographic","depth":5},{"value":"perspective","depth":5},{"value":"determinant(): number","depth":5},{"value":"transpose(): this","depth":5},{"value":"invert(): this","depth":5},{"value":"multiplyLeft(matrix: number16): this","depth":5},{"value":"multiplyRight(matrix: number16): this","depth":5},{"value":"rotateX(radians: number): this","depth":5},{"value":"rotateY(radians: number): this","depth":5},{"value":"rotateZ(radians: number): this","depth":5},{"value":"rotateXYZ(angles: rx: number, ry: number, rz: number): this","depth":5},{"value":"rotateAxis(radians: number, axis: number3): this","depth":5},{"value":"scale(factor: number | number3): this","depth":5},{"value":"translate(scale: number3): this","depth":5},{"value":"Decomposition","depth":4},{"value":"getRotation(result?: number16) : number16","depth":5},{"value":"getRotationMatrix3(result?: number9) : number9","depth":5},{"value":"getTranslation(result?: number3) : number3","depth":5},{"value":"getScale(result?: number3) : number3","depth":5},{"value":"Point Transformations","depth":4},{"value":"transformAsPoint(vector : number4) : number4","depth":5},{"value":"transformAsVector(vector : number4) : number4","depth":5},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/api-reference/matrix4","title":"Matrix4"},{"excerpt":"Quaternion A class to handle Quaternions. More information on quternions can be found  here . The quaternion will be represented by an instance with  x ,  y ,  z ,  w  components that make a quaternion like:  xi + yj + zk + w . Usage Members x, y, z, w Gets or sets element 0, 1, 2 or 3 respectively Methods Many of the most commonly used methods are inherited from  MathArray : quaternion.clone() quaternion.copy(array) quaternion.set(...args) quaternion.fromArray(array, offset = 0) quaternion.toString() quaternion.toArray(array = [], offset = 0) quaternion.equals(array) quaternion.exactEquals(array) quaternion.validate(array = this) quaternion.check(array = this) quaternion.normalize() Note that  Quaternion  is a subclass of the built in JavaScript  Array  and can thus technically be supplied as a parameter to any function expecting an  Array . constructor constructor(x = 0, y = 0, z = 0, w = 1) fromMatrix3(m: number 9 ): this Creates a quaternion from the given 3x3 rotation matrix. NOTE: The resultant quaternion is not normalized, so you should be sure to renormalize the quaternion yourself where necessary. fromMatrix3(m) fromValues(x: number, y: number, z: number, w): number: this Creates a new quat initialized with the given values fromValues(x, y, z, w) identity(): this Set a quat to the identity quaternion identity() length(): number Calculates the length of a quaternion length() squaredLength(): number Calculates the squared length of a quaternion squaredLength(a) @returnNumber} dot(): number Calculates the dot product of two quat's quaternion.dot(a, b) getAxisAngle Gets the rotation axis and angle for a given quaternion. quaternion.getAxisAngle() If a quaternion is created with setAxisAngle, this method will return the same values as providied in the original parameter list OR functionally equivalent values. Example: The quaternion formed by axis  0, 0, 1  and angle -90 is the same as the quaternion formed by  0, 0, 1  and 270. This method favors the latter. rotationTo Sets a quaternion to represent the shortest rotation from one vector to another. Both vectors are assumed to be unit length. quaternion.rotationTo(vectorA, vectorB) add Adds two quaternions quaternion.add(a, b) calculateW Calculates the W component of a quat from the X, Y, and Z components. Any existing W component will be ignored. quaternion.calculateW() conjugate Calculates the conjugate of a quat If the quaternion is normalized, this function is faster than quat_inverse and produces the same result. quaternion.conjugate() invert(): this Calculates the inverse of a quat quaternion.invert() lerp Performs a linear interpolation between two quat's quaternion.lerp(a, b, t) multiply Multiplies two quat's multiply(a, b) normalize Normalize a quat rotateX Rotates a quaternion by the given angle about the X axis rotateX(rad) rotateY Rotates a quaternion by the given angle about the Y axis rotateY(rad) rotateZ Rotates a quaternion by the given angle about the Z axis rotateZ(rad) scale Scales a quat by a scalar number scale(b) set Set the components of a quat to the given values set(i, j, k, l) setAxisAngle Sets a quat from the given angle and rotation axis, then returns it. setAxisAngle(axis, rad) slerp Performs a spherical linear interpolation between two quaternions slerp({start = [0, 0, 0, 1], target, ratio}) s","headings":[{"value":"Quaternion","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"x, y, z, w","depth":3},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"fromMatrix3(m: number9): this","depth":3},{"value":"fromValues(x: number, y: number, z: number, w): number: this","depth":3},{"value":"identity(): this","depth":3},{"value":"length(): number","depth":3},{"value":"squaredLength(): number","depth":3},{"value":"dot(): number","depth":3},{"value":"getAxisAngle","depth":3},{"value":"rotationTo","depth":3},{"value":"add","depth":3},{"value":"calculateW","depth":3},{"value":"conjugate","depth":3},{"value":"invert(): this","depth":3},{"value":"lerp","depth":3},{"value":"multiply","depth":3},{"value":"normalize","depth":3},{"value":"rotateX","depth":3},{"value":"rotateY","depth":3},{"value":"rotateZ","depth":3},{"value":"scale","depth":3},{"value":"set","depth":3},{"value":"setAxisAngle","depth":3},{"value":"slerp","depth":3}],"slug":"modules/core/docs/api-reference/quaternion","title":"Quaternion"},{"excerpt":"SphericalCoordinates This documentation is incomplete and may be incorrect See also  Wikipedia ,  Wolfram MathWorld . The poles (phi) are at the positive and negative y axis. The equator starts at positive z. Conversion from spherical to Cartesian (rectilinear) coordinates: Conversion from Cartesian (rectilinear) to spherical coordinates: Ranges Usage Creating a SphericalCoordinates object Converting to a direction  Vector3 Manipulating spherical coordinates; Members // Standard spherical coordinates phi theta radius altitude // lnglatZ coordinates lng lat z Methods constructor phi=0 - rotation around X (latitude) theta=0 - rotation around Y (longitude) radius=1 - Distance from center set set(radius, phi, theta) clone clone() copy copy(other) fromLngLatZ fromLngLatZ([lng, lat, z]) fromVector3 fromVector3(v) makeSafe makeSafe() // restrict phi to be betwee EPS and PI-EPS toVector3 toVector3(center = [0, 0, 0]) // TODO - add parameter for orientation of sphere? up vector etc? check Remarks Inspired by THREE.js  THREE.Spherical  class","headings":[{"value":"SphericalCoordinates","depth":1},{"value":"Usage","depth":2},{"value":"Members","depth":2},{"value":"phi","depth":3},{"value":"theta","depth":3},{"value":"radius","depth":3},{"value":"altitude","depth":3},{"value":"lng","depth":3},{"value":"lat","depth":3},{"value":"z","depth":3},{"value":"Methods","depth":2},{"value":"constructor","depth":3},{"value":"set","depth":3},{"value":"clone","depth":3},{"value":"copy","depth":3},{"value":"fromLngLatZ","depth":3},{"value":"fromVector3","depth":3},{"value":"makeSafe","depth":3},{"value":"toVector3","depth":3},{"value":"check","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/api-reference/spherical-coordinates","title":"SphericalCoordinates"},{"excerpt":"Math Utility Functions GLSL math function equivalents. Work on both single values and vectors. Usage Setting configuration Functions configure configure(options) checkNumber checkNumber(value) formatValue formatValue(value, precision = config.precision || 4) isArray Returns true if value is either an array or a typed array isArray(value) Note: does not return true for ArrayBuffers and DataViews clone clone(array)If the array has a clone function, calls it, otherwise returns a copy toRadians toRadians(degrees) Works on single values and vectors toDegrees toDegrees(radians) Works on single values and vectors equals equals(a, b, epsilon) Works on single values and vectors Numeric values need to be closer than  config.EPSILON Objects will be compared with their  .equals()  method if present. exactEquals exactEquals(a, b) Works on single values and vectors. Numeric values need to be exactly identical Objects will be compared with their  .exactEquals()  method if present. GLSL equivalents radians radians(degrees) GLSL equivalent: Works on single values and vectors degrees degrees(radians) GLSL equivalent: Works on single values and vectors sin sin(radians) GLSL equivalent: Works on single values and vectors cos cos(radians) GLSL equivalent: Works on single values and vectors tan tan(radians) GLSL equivalent: Works on single values and vectors asin asin(radians) GLSL equivalent: Works on single values and vectors acos acos(radians) GLSL equivalent: Works on single values and vectors atan atan(radians) clamp clamp(value, min, max) Remarks When setting global configs, you may need to consider the order of code loadint when using  imports  and  requires","headings":[{"value":"Math Utility Functions","depth":1},{"value":"Usage","depth":2},{"value":"Functions","depth":2},{"value":"configure","depth":3},{"value":"checkNumber","depth":3},{"value":"formatValue","depth":3},{"value":"isArray","depth":3},{"value":"clone","depth":3},{"value":"toRadians","depth":3},{"value":"toDegrees","depth":3},{"value":"equals","depth":3},{"value":"exactEquals","depth":3},{"value":"GLSL equivalents","depth":2},{"value":"radians","depth":3},{"value":"degrees","depth":3},{"value":"sin","depth":3},{"value":"cos","depth":3},{"value":"tan","depth":3},{"value":"asin","depth":3},{"value":"acos","depth":3},{"value":"atan","depth":3},{"value":"clamp","depth":3},{"value":"Remarks","depth":2}],"slug":"modules/core/docs/api-reference/utilities","title":"Math Utility Functions"},{"excerpt":"Vector Vector  is a base class for  Vector2 ,  Vector3  and  Vector4 , providing common methods to those classes. Inheritance class Vector extends [MathArray](./docs/api-reference/math-array) extends [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) Methods Vector.clone() Vector.copy(array) Vector.set(...args) Vector.fromArray(array, offset = 0) Vector.toString() Vector.toArray(array = [], offset = 0) Vector.equals(array) Vector.exactEquals(array) Vector.validate(array = this) Vector.check(array = this) Vector.normalize()","headings":[{"value":"Vector","depth":1},{"value":"Inheritance","depth":2},{"value":"Methods","depth":2},{"value":"Vector.clone()","depth":3},{"value":"Vector.copy(array)","depth":3},{"value":"Vector.set(...args)","depth":3},{"value":"Vector.fromArray(array, offset = 0)","depth":3},{"value":"Vector.toString()","depth":3},{"value":"Vector.toArray(array = [], offset = 0)","depth":3},{"value":"Vector.equals(array)","depth":3},{"value":"Vector.exactEquals(array)","depth":3},{"value":"Vector.validate(array = this)","depth":3},{"value":"Vector.check(array = this)","depth":3},{"value":"Vector.normalize()","depth":3}],"slug":"modules/core/docs/api-reference/vector","title":"Vector"},{"excerpt":"Vector3 Usage Accessors Simple rotations Scaling with constants Scaling with vectors is very flexible, you can e.g. set a component to zero, or flip a component's sign. Inheritance Vector3  extends  Vector  extends  MathArray  extends  Array Members x, y, z Gets or sets element 0, 1 or 2 respectively Methods Many of the most commonly used  Vector3  methods are inherited from  MathArray : Vector3.clone() Vector3.copy(array) Vector3.set(...args) Vector3.fromArray(array, offset = 0) Vector3.toString() Vector3.toArray(array = [], offset = 0) Vector3.equals(array) Vector3.exactEquals(array) Vector3.validate(array = this) Vector3.check(array = this) Vector3.normalize() Note that  Vector3  is a subclass of the built in JavaScript  Array  and can thus e.g. be supplied as a parameter to any function expecting an  Array . constructor(x = 0, y = 0, z = 0) set(x, y, z) length() distance(vector) angle(vector) dot(vector) // MODIFIERS add(...vectors) subtract(...vectors) multiply(...vectors) divide(...vectors) scale(scale) Scale component wise with a scalar or another  Vector3 . scale  (Number|Vector3) - scale component wise with a scalar or another  Vector3 . negate negate() inverse inverse() normalize normalize() cross cross(vector) lerp lerp(vector, coeff) rotateX Rotate a 3D vector around the x-axis rotateX({radians, origin}) radians  (Number) - angle to rotate. origin = [0, 0, 0]  (Vector3) - the origin of the rotation (optional) rotateY Rotate a 3D vector around the y-axis rotateY({radians, origin}) radians  (Number) - angle to rotate. origin = [0, 0, 0]  (Vector3) - the origin of the rotation (optional) rotateZ(radians) Rotate a 3D vector around the z-axis rotateZ({radians, origin}) radians  (Number) - angle to rotate. origin = [0, 0, 0]  (Vector3) - the origin of the rotation (optional) transform(matrix4 : Number 16 ) : Vector4 Transforms the vector by the provided 4x4 matrix. Note: Scales the resulting vector to ensure that  w , if non-zero, is set to  1 . transformByMatrix3(matrix3 : Number 9 ) : Vector4 Transforms the vector by the provided 3x3 matrix. transformByMatrix2(matrix2 : Number 4 ) : Vector4 Transform the vector's  x  and  y  values by the provided 2x2 matrix. transformByQuaternion(quaternion : Number 4 ) : Vector4 Transform the vector by the provided  quaternion .","headings":[{"value":"Vector3","depth":1},{"value":"Usage","depth":2},{"value":"Inheritance","depth":2},{"value":"Members","depth":2},{"value":"x, y, z","depth":3},{"value":"Methods","depth":2},{"value":"constructor(x = 0, y = 0, z = 0)","depth":3},{"value":"set(x, y, z)","depth":3},{"value":"length()","depth":3},{"value":"distance(vector)","depth":3},{"value":"angle(vector)","depth":3},{"value":"dot(vector)","depth":3},{"value":"add(...vectors)","depth":3},{"value":"subtract(...vectors)","depth":3},{"value":"multiply(...vectors)","depth":3},{"value":"divide(...vectors)","depth":3},{"value":"scale(scale)","depth":3},{"value":"negate","depth":3},{"value":"inverse","depth":3},{"value":"normalize","depth":3},{"value":"cross","depth":3},{"value":"lerp","depth":3},{"value":"rotateX","depth":3},{"value":"rotateY","depth":3},{"value":"rotateZ(radians)","depth":3},{"value":"transform(matrix4 : Number16) : Vector4","depth":3},{"value":"transformByMatrix3(matrix3 : Number9) : Vector4","depth":3},{"value":"transformByMatrix2(matrix2 : Number4) : Vector4","depth":3},{"value":"transformByQuaternion(quaternion : Number4) : Vector4","depth":3}],"slug":"modules/core/docs/api-reference/vector3","title":"Vector3"},{"excerpt":"Vector4 Vector4  is designed to hold three dimensional coordinates in projective space. Using the projective representation allows JavaScript applications to perform the same calculations that the GPU does. A main feature of vectors is that they can be transformed by matrices and quaternions. And  Vector4 s are particular general when transformed with 4x4 matrices ( Matrix4  or just arrays of 16 numbers), as those can include translations, projections and other transformations that cannot be expressed by e.g. 3x3 matrices or quaternions alone. Note that the fourth element  w  is not a coordinate but a scaling factor. The fourth component ( w ) is usually set to either 0  to represent a vector 1  to represent a point Vector4  methods will keep the vector scaled so that  w  (if non-zero) is  1 . The math behind  Vector4  comes from projective geometry, which significantly generalizes calculations and removes a number of special cases compared to affine geometry. It is not necessary to understand the details to use  Vector4 , but see the developer guide for some additional xbackground. Usage Inheritance Vector4  extends  Vector  extends  MathArray  extends  Array Members x, y, z, w Gets or sets element 0, 1, 2 or 3 respectively Methods Many of the most commonly used  Vector2  methods are inherited from  MathArray : Vector4.clone() Vector4.copy(array) Vector4.set(...args) Vector4.fromArray(array, offset = 0) Vector4.toString() Vector4.toArray(array = [], offset = 0) Vector4.equals(array) Vector4.exactEquals(array) Vector4.validate(array = this) Vector4.check(array = this) Vector4.normalize() Note that  Vector2  is a subclass of the built in JavaScript  Array  and can thus e.g. be supplied as a parameter to any function expecting an  Array . constructor(x?: number, y?: number, z?: number, w?: number) new Vector4(x = 0, y = 0, z = 0, w = 0) Creates a new, empty  Vector4 set(x?: number, y?: number, z?: number, w?: number): thos Updates a  Vector4 distance(vector: number 4 ): number Returns the distance to the specifed Vector. distanceSquared(vector: number 4 ): number Returns the squared distance to the specifed Vector. Fast to calculate than distance and often sufficient for e.g. sorting etc. dot(vector: number 4 ): number Calculates the dot product with the supplied  vector . add(vector: number 4 ): Vector4 add(...vectors) subtract(vector: number 4 ): Vector4 subtract(...vectors) multiply(vector: number 4 ): Vector4 multiply(...vectors) divide(vector: number 4 ): Vector4 divide(...vectors) scale(vector: number 4 ): Vector4 scale(scale) negate(): this Negates each element in the vector. inverse(): this Inverses ( x = 1/x ) each element in the vector. normalize(): this Normalizes the vector. Same direction but  len()  will now return  1 . lerp(vector: number 4 , coefficient: number): this Linearly interpolates between the vectors current value and the supplied  vector . transform(matrix4: number 16 ): Vector4 Equivalent to  transformByMatrix4 . transformByMatrix4(matrix4: number 16 ): Vector4 Transforms a vector by the provided 4x4 matrix. Note: Scales the resulting vector to ensure that  w , if non-zero, is set to  1 . transformByMatrix3(matrix3: number 9 ): Vector4 Transforms the vector's  x ,  y  and  z  values by the provided 3x3 matrix. transformByMatrix2(matrix2: number 4 ): Vector4 Transform the vector's  x  and  y  values by the provided 2x2 matrix. transformByQuaternion(quaternion: number 4 ): Vector4 Transform the vector by the provided  quaternion .","headings":[{"value":"Vector4","depth":1},{"value":"Usage","depth":2},{"value":"Inheritance","depth":2},{"value":"Members","depth":2},{"value":"x, y, z, w","depth":3},{"value":"Methods","depth":2},{"value":"constructor(x?: number, y?: number, z?: number, w?: number)","depth":3},{"value":"set(x?: number, y?: number, z?: number, w?: number): thos","depth":3},{"value":"distance(vector: number4): number","depth":3},{"value":"distanceSquared(vector: number4): number","depth":3},{"value":"dot(vector: number4): number","depth":3},{"value":"add(vector: number4): Vector4","depth":3},{"value":"subtract(vector: number4): Vector4","depth":3},{"value":"multiply(vector: number4): Vector4","depth":3},{"value":"divide(vector: number4): Vector4","depth":3},{"value":"scale(vector: number4): Vector4","depth":3},{"value":"negate(): this","depth":3},{"value":"inverse(): this","depth":3},{"value":"normalize(): this","depth":3},{"value":"lerp(vector: number4, coefficient: number): this","depth":3},{"value":"transform(matrix4: number16): Vector4","depth":3},{"value":"transformByMatrix4(matrix4: number16): Vector4","depth":3},{"value":"transformByMatrix3(matrix3: number9): Vector4","depth":3},{"value":"transformByMatrix2(matrix2: number4): Vector4","depth":3},{"value":"transformByQuaternion(quaternion: number4): Vector4","depth":3}],"slug":"modules/core/docs/api-reference/vector4","title":"Vector4"},{"excerpt":"Vector2 A two dimensional vector Usage Inheritance Vector2  extends  Vector  extends  MathArray  extends  Array Many commonly used  Vector2  methods are inherited from  Vector  and  MathArray : Vector2.clone() Vector2.copy(array) Vector2.set(...args) Vector2.fromArray(array, offset = 0) Vector2.toString() Vector2.toArray(array = [], offset = 0) Vector2.equals(array) Vector2.exactEquals(array) Vector2.validate(array = this) Vector2.check(array = this) Vector2.normalize() Also note that  Vector2  is a subclass of the built in JavaScript  Array  and can thus be used wherever an Array is expected. It can e.g. supplied as a parameter to any function expecting an  Array . Members x, y Gets or sets element 0 or 1 respectively constructor Creates a new, empty  Vector2 , or copies an existing  Vector2 set set(x, y) add Add zero or more vectors to current vector. add(...vectors) subtract Subtract zero or more vectors from current vector subtract(...vectors) multiply Multiply zero or more vectors with current vector multiply(...vectors) divide Divide zero or more vectors with current vector divide(...vectors) scale scale(scale) scaleAndAdd scaleAndAdd(vector, scale) negate negate() normalize normalize() dot dot(vector) lerp lerp(vector, coeff) horizontalAngle Calculates counterclockwise angle in radians starting from positive x axis horizontalAngle() Note: returns  Math.atan2(this.y, this.x) verticalAngle Calculates clockwise angle in radians starting from positive y axis verticalAngle() Note: returns  Math.atan2(this.x, this.y) transform(matrix4 : Number 16 ) : Vector4 Equivalent to  transformAsPoint . transformAsPoint(matrix4 : Number 16 ) : Vector4 Transforms this vector by the provided 4x4 matrix as a point (i.e includes translations). Note: Implicitly extends the vector to  [x, y, 0, 1]  before applying the 4x4 transformation. transformAsVector(matrix4 : Number 16 ) : Vector4 Transforms this vector by the provided 4x4 matrix as a vector (i.e does not include translations). Note: Implicitly extends the vector to  [x, y, 0, 0]  before applying the 4x4 transformation. transformByMatrix3(matrix3 : Number 9 ) : Vector4 Transforms this vector by the provided 3x3 matrix. transformByMatrix2x3(matrix2 : Number 6 ) : Vector4 Transforms this vector by the provided 2x3 matrix (A pure 2D transform that can incorporate translations). transformByMatrix2(matrix2 : Number 4 ) : Vector4 Transforms this vector by the provided 2x2 matrix.","headings":[{"value":"Vector2","depth":1},{"value":"Usage","depth":2},{"value":"Inheritance","depth":2},{"value":"Members","depth":2},{"value":"x, y","depth":3},{"value":"constructor","depth":3},{"value":"set","depth":3},{"value":"add","depth":3},{"value":"subtract","depth":3},{"value":"multiply","depth":3},{"value":"divide","depth":3},{"value":"scale","depth":3},{"value":"scaleAndAdd","depth":3},{"value":"negate","depth":3},{"value":"normalize","depth":3},{"value":"dot","depth":3},{"value":"lerp","depth":3},{"value":"horizontalAngle","depth":3},{"value":"verticalAngle","depth":3},{"value":"transform(matrix4 : Number16) : Vector4","depth":3},{"value":"transformAsPoint(matrix4 : Number16) : Vector4","depth":3},{"value":"transformAsVector(matrix4 : Number16) : Vector4","depth":3},{"value":"transformByMatrix3(matrix3 : Number9) : Vector4","depth":3},{"value":"transformByMatrix2x3(matrix2 : Number6) : Vector4","depth":3},{"value":"transformByMatrix2(matrix2 : Number4) : Vector4","depth":3}],"slug":"modules/core/docs/api-reference/vector2","title":"Vector2"},{"excerpt":"Add custom components here.","headings":[],"slug":"website/src","title":""}]}},"staticQueryHashes":["484347790"]}